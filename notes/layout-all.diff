 app/ChatInterface.tsx                              | 406 ----------------
 app/app.css                                        |  53 +-
 app/components/AppLayout.tsx                       |  37 ++
 app/components/ChatHeader.tsx                      |  29 +-
 app/components/ChatHeaderContent.tsx               |  76 +++
 app/components/ChatInput.tsx                       |  14 +-
 app/components/ChatInterface.tsx                   | 121 +++++
 app/components/Message.tsx                         | 153 ++++++
 app/components/MessageList.tsx                     | 219 ++-------
 app/components/QuickSuggestions.tsx                |   2 +-
 app/components/ResultPreview/ResultPreview.tsx     | 532 ++++-----------------
 .../ResultPreview/ResultPreviewHeaderContent.tsx   | 155 ++++++
 .../ResultPreview/ResultPreviewTemplates.ts        |  89 ++++
 .../ResultPreview/ResultPreviewToolbar.tsx         | 155 ++++++
 app/components/ResultPreview/ResultPreviewTypes.ts |  19 +
 app/components/ResultPreview/ResultPreviewUtils.ts |  14 +
 app/components/ResultPreview/SandpackContent.tsx   | 143 ++++++
 .../ResultPreview/SandpackEventListener.tsx        |  40 --
 .../ResultPreview/SandpackScrollController.tsx     | 510 ++++++++++++++------
 app/components/ResultPreview/WelcomeScreen.tsx     |   2 +-
 app/components/SessionSidebar.tsx                  | 230 ++-------
 app/components/SessionSidebar/ImgFile.tsx          |  29 ++
 app/components/SessionSidebar/utils.ts             |  12 +
 app/components/StructuredMessage.tsx               | 103 ++++
 app/config/env.ts                                  |  11 +
 app/context/ChatContext.tsx                        | 134 ------
 app/hooks/sidebar/useSessionList.ts                |  98 ++++
 app/hooks/useChat.ts                               | 390 ---------------
 app/hooks/useChatSessions.ts                       |  85 ----
 app/hooks/useSession.ts                            | 108 +++++
 app/hooks/useSimpleChat.ts                         | 173 +++++++
 app/prompts.ts                                     |   2 +-
 app/routes.ts                                      |   2 +-
 app/routes/home.tsx                                | 442 +++--------------
 app/routes/session.tsx                             | 137 ------
 app/tests/ChatInterface.test.tsx                   |  63 ---
 app/types/chat.ts                                  | 149 ++++--
 app/utils/debugLogging.ts                          | 145 ++++++
 app/utils/openRouterApi.ts                         |   0
 app/utils/segmentParser.ts                         | 121 +++++
 app/utils/sharing.ts                               |  68 +++
 app/utils/streamHandler.ts                         | 111 +++++
 app/utils/titleGenerator.ts                        |  59 +++
 43 files changed, 2814 insertions(+), 2627 deletions(-)
diff --git a/app/ChatInterface.tsx b/app/ChatInterface.tsx
deleted file mode 100644
index 1be05f1..0000000
--- a/app/ChatInterface.tsx
+++ /dev/null
@@ -1,406 +0,0 @@
-import { useEffect, useState, useMemo, useCallback, useRef } from 'react';
-import type { ChatMessage, SessionDocument } from './types/chat';
-import { useFireproof } from 'use-fireproof';
-import SessionSidebar from './components/SessionSidebar';
-import ChatHeader from './components/ChatHeader';
-import MessageList from './components/MessageList';
-import ChatInput from './components/ChatInput';
-import QuickSuggestions from './components/QuickSuggestions';
-import { useChatContext } from './context/ChatContext';
-
-interface ChatInterfaceProps {
-  chatState: {
-    messages: ChatMessage[];
-    setMessages: React.Dispatch<React.SetStateAction<ChatMessage[]>>;
-    input: string;
-    setInput: React.Dispatch<React.SetStateAction<string>>;
-    isGenerating: boolean;
-    currentStreamedText: string;
-    streamingCode: string;
-    completedCode: string;
-    isStreaming: boolean;
-    inputRef: React.RefObject<HTMLTextAreaElement | null>;
-    messagesEndRef: React.RefObject<HTMLDivElement | null>;
-    autoResizeTextarea: () => void;
-    scrollToBottom: () => void;
-    sendMessage: () => Promise<void>;
-    parserState: React.MutableRefObject<{
-      inCodeBlock: boolean;
-      codeBlockContent: string;
-      dependencies: Record<string, string>;
-      displayText: string;
-      on: (event: string, callback: Function) => void;
-      removeAllListeners: () => void;
-      write: (chunk: string) => void;
-      end: () => void;
-      reset: () => void;
-    }>;
-    completedMessage: string;
-  };
-  sessionId?: string | null;
-  onSessionCreated?: (newSessionId: string) => void;
-  onNewChat?: () => void;
-  onCodeGenerated?: (code: string, dependencies?: Record<string, string>) => void;
-}
-
-// Helper function to encode titles for URLs
-function encodeTitle(title: string): string {
-  return encodeURIComponent(title || 'untitled-session')
-    .toLowerCase()
-    .replace(/%20/g, '-');
-}
-
-// ChatInterface component handles user input and displays chat messages
-function ChatInterface({
-  chatState,
-  sessionId,
-  onSessionCreated,
-  onNewChat,
-  onCodeGenerated,
-}: ChatInterfaceProps) {
-  const [isShrinking, setIsShrinking] = useState(false);
-  const [isExpanding, setIsExpanding] = useState(false);
-  const { database, useLiveQuery } = useFireproof('fireproof-chat-history');
-
-  // Maintain a stable ref to the database to prevent re-renders
-  const databaseRef = useRef(database);
-
-  // Update database ref when it changes
-  useEffect(() => {
-    databaseRef.current = database;
-  }, [database]);
-
-  const {
-    messages,
-    setMessages,
-    input,
-    setInput,
-    isGenerating,
-    currentStreamedText,
-    inputRef,
-    autoResizeTextarea,
-    sendMessage,
-  } = chatState;
-
-  // Query chat sessions ordered by timestamp (newest first)
-  const { docs: sessions } = useLiveQuery('timestamp', {
-    descending: true,
-  });
-
-  // Get values from context when available
-  const chatContext = useChatContext();
-
-  // Create a ref to store setMessages function to avoid dependency cycles
-  const setMessagesRef = useRef(setMessages);
-
-  // Keep the ref updated with the latest setMessages function
-  useEffect(() => {
-    setMessagesRef.current = setMessages;
-  }, [setMessages]);
-
-  // Track if we are manually setting input to prevent feedback loops
-  const isSettingInput = useRef(false);
-
-  // Memoize handler functions to prevent re-renders
-  const handleSelectSuggestion = useCallback(
-    (suggestion: string) => {
-      // Set local state directly
-      setInput(suggestion);
-
-      // Focus the input after setting the value
-      setTimeout(() => {
-        if (inputRef.current) {
-          inputRef.current.focus();
-        }
-      }, 0);
-    },
-    [inputRef, setInput]
-  );
-
-  // Focus input on mount
-  useEffect(() => {
-    inputRef.current?.focus();
-  }, [inputRef]);
-
-  // Auto-resize textarea when input changes
-  useEffect(() => {
-    autoResizeTextarea();
-  }, [autoResizeTextarea]);
-
-  // Load session data when sessionId changes
-  useEffect(() => {
-    async function loadSessionData() {
-      if (sessionId) {
-        try {
-          const sessionData = (await databaseRef.current.get(sessionId)) as SessionDocument;
-          // Normalize session data to guarantee messages array exists
-          const messages = Array.isArray(sessionData.messages) ? sessionData.messages : [];
-          // Use the ref to access the latest setMessages function
-          setMessagesRef.current(messages);
-        } catch (error) {
-          console.error('ChatInterface: Error loading session:', error);
-        }
-      }
-    }
-
-    // Only load session data if we have a sessionId and it's not already loading
-    const loadingTimeoutId = setTimeout(() => {
-      loadSessionData();
-    }, 0);
-
-    return () => {
-      clearTimeout(loadingTimeoutId);
-    };
-  }, [sessionId, databaseRef]); // Keep only essential dependencies
-
-  // Track streaming state to detect when streaming completes
-  const wasGeneratingRef = useRef(isGenerating);
-
-  // Save messages to Fireproof ONLY when streaming completes or on message count change
-  useEffect(() => {
-    async function saveSessionData() {
-      // Only save when streaming just completed (wasGenerating was true, but isGenerating is now false)
-      const streamingJustCompleted = wasGeneratingRef.current && !isGenerating;
-
-      if (messages.length > 0 && streamingJustCompleted) {
-        // Extract title from first user message
-        const firstUserMessage = messages.find((msg) => msg.type === 'user');
-        const title = firstUserMessage?.text || 'Untitled Chat';
-
-        try {
-          const sessionData = {
-            type: 'session',
-            title,
-            messages,
-            timestamp: Date.now(),
-            ...(sessionId ? { _id: sessionId } : {}),
-          };
-
-          const result = await databaseRef.current.put(sessionData);
-
-          // If this was a new session, notify the parent component using optional chaining
-          if (!sessionId) {
-            // Update the URL in the browser history without reloading
-            const encodedTitle = encodeTitle(title);
-            const url = `/session/${result.id}/${encodedTitle}`;
-            window.history.pushState({ sessionId: result.id }, '', url);
-
-            // Notify parent component
-            onSessionCreated?.(result.id);
-          }
-        } catch (error) {
-          console.error('Error saving session to Fireproof:', error);
-        }
-      }
-
-      // Update ref for next comparison
-      wasGeneratingRef.current = isGenerating;
-    }
-
-    saveSessionData();
-  }, [isGenerating, sessionId]); // Minimize dependencies
-
-  // Load a session from the sidebar
-  const handleLoadSession = useCallback(
-    async (session: SessionDocument) => {
-      // Ensure session has an _id - this is guaranteed by the component API
-      const sessionId = session._id;
-
-      try {
-        const sessionData = (await databaseRef.current.get(sessionId)) as SessionDocument;
-        // Normalize session data to guarantee messages array exists
-        const messages = Array.isArray(sessionData.messages) ? sessionData.messages : [];
-        // Use the ref to access the latest setMessages function
-        setMessagesRef.current(messages);
-
-        // Find the last AI message with code to update the editor
-        const lastAiMessageWithCode = [...messages]
-          .reverse()
-          .find((msg: ChatMessage) => msg.type === 'ai' && msg.code);
-
-        // If we found an AI message with code, update the code view
-        if (lastAiMessageWithCode?.code) {
-          const dependencies = lastAiMessageWithCode.dependencies || {};
-
-          // 1. Update local chatState
-          chatState.streamingCode = lastAiMessageWithCode.code;
-          chatState.completedCode = lastAiMessageWithCode.code;
-          chatState.parserState.current.dependencies = dependencies;
-          chatState.isStreaming = false;
-          chatState.isGenerating = false;
-
-          // Manually extract the UI code for app preview
-          chatState.completedMessage = lastAiMessageWithCode.text || "Here's your app:";
-
-          // 2. Call the onCodeGenerated callback to update parent state
-          onCodeGenerated?.(lastAiMessageWithCode.code, dependencies);
-        } else {
-          // No code found in session
-        }
-
-        // Notify parent component of session change
-        onSessionCreated?.(sessionId);
-      } catch (error) {
-        console.error('ChatInterface.handleLoadSession: Error loading session:', error);
-      }
-    },
-    [databaseRef, chatState, onCodeGenerated, onSessionCreated]
-  );
-
-  // Handle the "New Chat" button click
-  const handleNewChatButtonClick = useCallback(() => {
-    // Start the shrinking animation
-    setIsShrinking(true);
-    setIsExpanding(false);
-
-    // After animation completes, reset the state
-    setTimeout(
-      () => {
-        // If onNewChat callback is provided, call it
-        if (onNewChat) {
-          onNewChat();
-        }
-
-        // Clear the UI without clearing saved messages yet
-        setInput('');
-
-        // Navigate to the root path
-        // window.history.pushState({ sessionId: null }, '', '/');
-        window.location.href = '/';
-
-        // // Reset animation states
-        // setIsShrinking(false);
-
-        // // Add a small bounce effect when the new chat appears
-        // setIsExpanding(true);
-        // setTimeout(() => {
-        //   setIsExpanding(false);
-        // }, 300);
-
-        // // Clear messages once animation is complete and navigation happened
-        // setTimeout(() => {
-        //   setMessages([]);
-        // }, 100);
-      },
-      500 + messages.length * 50
-    );
-  }, [onNewChat, messages.length, setInput, setMessages, setIsShrinking, setIsExpanding]);
-
-  const handleSelectSession = (session: SessionDocument) => {
-    // Navigate to the session route
-    const encodedTitle = encodeTitle(session.title || 'Untitled Session');
-    const url = `/session/${session._id}/${encodedTitle}`;
-
-    // Use window.location.href to force a full page reload to the new URL
-    window.location.href = url;
-
-    // No need to call onSessionCreated since the page will reload
-    // and the Session component will handle initializing with the new sessionId
-  };
-
-  // This function will be called when a new session is created
-  const handleSessionCreated = (newSessionId: string) => {
-    // If there's a provided callback, call it
-    if (onSessionCreated) {
-      onSessionCreated(newSessionId);
-    }
-
-    // Navigate to the new session without reloading by pushing to history state
-    // This allows for a seamless experience when creating a new session during streaming
-    const url = `/session/${newSessionId}/new-session`;
-    window.history.pushState({ sessionId: newSessionId }, '', url);
-  };
-
-  // Memoize child components to prevent unnecessary re-renders
-  const chatHeader = useMemo(
-    () => (
-      <ChatHeader
-        onOpenSidebar={chatContext.openSidebar}
-        onNewChat={handleNewChatButtonClick}
-        isGenerating={isGenerating}
-      />
-    ),
-    [chatContext.openSidebar, handleNewChatButtonClick, isGenerating]
-  );
-
-  const sessionSidebar = useMemo(
-    () => (
-      <SessionSidebar
-        isVisible={chatContext.isSidebarVisible}
-        onClose={chatContext.closeSidebar}
-        onSelectSession={handleSelectSession}
-      />
-    ),
-    [chatContext.isSidebarVisible, chatContext.closeSidebar, handleSelectSession]
-  );
-
-  const messageList = useMemo(
-    () => (
-      <MessageList
-        messages={messages}
-        isGenerating={isGenerating}
-        currentStreamedText={currentStreamedText}
-        isShrinking={isShrinking}
-        isExpanding={isExpanding}
-      />
-    ),
-    [messages, isGenerating, currentStreamedText, isShrinking, isExpanding]
-  );
-
-  const quickSuggestions = useMemo(
-    () => messages.length === 0 && <QuickSuggestions onSelectSuggestion={handleSelectSuggestion} />,
-    [messages.length, handleSelectSuggestion]
-  );
-
-  // Memoize ChatInput with direct props instead of relying on context
-  const chatInput = useMemo(() => {
-    return (
-      <ChatInput
-        value={input}
-        onChange={(e) => {
-          setInput(e.target.value);
-        }}
-        onSend={sendMessage}
-        disabled={isGenerating}
-        inputRef={inputRef}
-        onKeyDown={(e) => {
-          if (e.key === 'Enter' && !e.shiftKey && !isGenerating) {
-            e.preventDefault();
-            sendMessage();
-          }
-        }}
-      />
-    );
-  }, [input, isGenerating, setInput, sendMessage, inputRef]);
-
-  // Keep isGenerating in sync with context
-  useEffect(() => {
-    if (chatState.isGenerating !== chatContext.isGenerating) {
-      chatContext.setIsGenerating(chatState.isGenerating);
-    }
-  }, [chatContext, chatState.isGenerating]);
-
-  return (
-    <div className="relative flex h-full w-full flex-col overflow-hidden">
-      {chatHeader}
-      <SessionSidebar
-        isVisible={chatContext.isSidebarVisible}
-        onClose={chatContext.closeSidebar}
-        onSelectSession={handleSelectSession}
-      />
-
-      <div className="relative flex flex-col overflow-y-auto" style={{ flexGrow: 1 }}>
-        {/* Message list */}
-        {messageList}
-
-        {/* Quick access buttons */}
-        {quickSuggestions}
-
-        {/* Chat input */}
-        {chatInput}
-      </div>
-    </div>
-  );
-}
-
-export default ChatInterface;
diff --git a/app/app.css b/app/app.css
index 7d7e885..0e5febf 100644
--- a/app/app.css
+++ b/app/app.css
@@ -263,7 +263,7 @@ a,
 .pulsing {
   width: 100%;
   height: auto;
-  transform: rotate(-5deg) scale(4);
+  transform: rotate(-5deg) scale(6);
   animation: pulse 8s infinite;
 }
 
@@ -280,7 +280,7 @@ a,
 }
 .logo-pulse {
   transform: rotate(-5deg) scale(4);
-  animation: logo-rotate 30s ease-in-out infinite;
+  animation: logo-rotate 33s ease-in-out infinite, logo-pulse-height 21s ease-in-out infinite;
 }
 
 @keyframes logo-rotate {
@@ -294,3 +294,52 @@ a,
     transform: rotate(0deg) scale(1);
   }
 }
+
+@keyframes logo-pulse-height {
+  0% {
+    width: 80%;
+  }
+  50% {
+    width: 120%;
+  }
+  100% {
+    width: 80%;
+  }
+}
+
+.ai-markdown ul {
+  list-style-type: disc;
+  padding-left: 1rem;
+  padding-top: 0.5rem;
+}
+
+.ai-markdown ol {
+  list-style-type: decimal;
+  padding-left: 1rem;
+  padding-top: 0.5rem;
+}
+
+.ai-markdown li {
+  margin-bottom: 0.5rem;
+}
+
+.ai-markdown h1 {
+  font-size: 1.8rem;
+  font-weight: 700;
+  margin-top: 1rem;
+  margin-bottom: 1rem;
+}
+
+.ai-markdown h2 {
+  font-size: 1.5rem;
+  font-weight: 600;
+  margin-top: 1rem;
+  margin-bottom: 0.75rem;
+}
+
+.ai-markdown h3 {
+  font-size: 1.25rem;
+  font-weight: 600;
+  margin-top: 0.75rem;
+  margin-bottom: 0.5rem;
+}
diff --git a/app/components/AppLayout.tsx b/app/components/AppLayout.tsx
new file mode 100644
index 0000000..3f7dbb8
--- /dev/null
+++ b/app/components/AppLayout.tsx
@@ -0,0 +1,37 @@
+import type { ReactNode } from 'react';
+
+interface AppLayoutProps {
+  chatPanel: ReactNode;
+  previewPanel: ReactNode;
+  headerLeft?: ReactNode;
+  headerRight?: ReactNode;
+}
+
+/**
+ * AppLayout - Common layout component for the application
+ * Provides consistent structure with 1:3 ratio between chat panel and preview panel
+ * Can optionally render header components above the content panels
+ */
+export default function AppLayout({ 
+  chatPanel, 
+  previewPanel, 
+  headerLeft, 
+  headerRight 
+}: AppLayoutProps) {
+  return (
+    <div className="flex h-dvh flex-col overflow-hidden">
+      <div className="flex h-[4rem] w-full border-b border-light-decorative-00 dark:border-dark-decorative-00">
+        <div className="w-1/3 border-light-decorative-00 dark:border-dark-decorative-00">
+          {headerLeft}
+        </div>
+        <div className="w-2/3">
+          {headerRight}
+        </div>
+      </div>
+      <div className="flex flex-1 overflow-hidden">
+        <div className="flex h-full w-1/3 flex-col">{chatPanel}</div>
+        <div className="relative w-2/3">{previewPanel}</div>
+      </div>
+    </div>
+  );
+}
diff --git a/app/components/ChatHeader.tsx b/app/components/ChatHeader.tsx
index 05ae2d2..93aaeb2 100644
--- a/app/components/ChatHeader.tsx
+++ b/app/components/ChatHeader.tsx
@@ -3,21 +3,14 @@ import { useNavigate } from 'react-router';
 
 interface ChatHeaderProps {
   onOpenSidebar: () => void;
-  onNewChat: () => void;
-  isGenerating: boolean;
+  title: string;
 }
 
-function ChatHeader({ onOpenSidebar, onNewChat, isGenerating }: ChatHeaderProps) {
+function ChatHeader({ onOpenSidebar, title }: ChatHeaderProps) {
   const navigate = useNavigate();
 
-  const handleNewChat = (e: React.MouseEvent) => {
-    e.preventDefault();
-    onNewChat();
-    // Navigation will happen in the onNewChat callback
-  };
-
   return (
-    <div className="border-light-decorative-00 dark:border-dark-decorative-00 bg-light-background-00 dark:bg-dark-background-00 flex min-h-[4rem] items-center justify-between border-b px-6 py-4">
+    <div className="border-light-decorative-00 dark:border-dark-decorative-00 bg-light-background-00 dark:bg-dark-background-00 flex h-[4rem] items-center justify-between border-b px-6 py-4">
       <div className="flex items-center">
         <button
           type="button"
@@ -42,15 +35,18 @@ function ChatHeader({ onOpenSidebar, onNewChat, isGenerating }: ChatHeaderProps)
           </svg>
         </button>
       </div>
+      <div className="text-light-primary dark:text-dark-primary text-sm">{title}</div>
       <div className="relative">
         <button
           type="button"
-          onClick={handleNewChat}
+          onClick={() => {
+            document.location = '/';
+          }}
           className="peer bg-accent-02-light dark:bg-accent-02-dark hover:bg-accent-03-light dark:hover:bg-accent-03-dark flex cursor-pointer items-center justify-center rounded-full p-2.5 text-white transition-colors"
-          disabled={isGenerating}
           aria-label="New Chat"
           title="New Chat"
         >
+          <span className="sr-only">New Chat</span>
           <svg
             xmlns="http://www.w3.org/2000/svg"
             className="h-5 w-5"
@@ -78,11 +74,6 @@ function ChatHeader({ onOpenSidebar, onNewChat, isGenerating }: ChatHeaderProps)
 // Use React.memo with a custom comparison function to ensure the component only
 // re-renders when its props actually change
 export default memo(ChatHeader, (prevProps, nextProps) => {
-  // Only re-render if isGenerating changes
-  // Note: Functions should be memoized by parent components
-  return (
-    prevProps.isGenerating === nextProps.isGenerating &&
-    prevProps.onNewChat === nextProps.onNewChat &&
-    prevProps.onOpenSidebar === nextProps.onOpenSidebar
-  );
+  // Only re-render if title or openSidebar or title changes
+  return prevProps.onOpenSidebar === nextProps.onOpenSidebar && prevProps.title === nextProps.title;
 });
diff --git a/app/components/ChatHeaderContent.tsx b/app/components/ChatHeaderContent.tsx
new file mode 100644
index 0000000..6d18b9c
--- /dev/null
+++ b/app/components/ChatHeaderContent.tsx
@@ -0,0 +1,76 @@
+import { memo } from 'react';
+
+interface ChatHeaderContentProps {
+  onOpenSidebar: () => void;
+  title: string;
+}
+
+function ChatHeaderContent({ onOpenSidebar, title }: ChatHeaderContentProps) {
+  return (
+    <div className="flex h-full w-full items-center justify-between px-6 py-4">
+      <div className="flex items-center">
+        <button
+          type="button"
+          onClick={onOpenSidebar}
+          className="text-light-primary dark:text-dark-primary hover:text-accent-02-light dark:hover:text-accent-02-dark mr-3"
+          aria-label="Open chat history"
+        >
+          <svg
+            xmlns="http://www.w3.org/2000/svg"
+            className="h-6 w-6"
+            fill="none"
+            viewBox="0 0 24 24"
+            stroke="currentColor"
+            aria-hidden="true"
+          >
+            <path
+              strokeLinecap="round"
+              strokeLinejoin="round"
+              strokeWidth={2}
+              d="M4 6h16M4 12h16M4 18h7"
+            />
+          </svg>
+        </button>
+      </div>
+      <div className="text-light-primary dark:text-dark-primary text-sm">{title}</div>
+      <div className="relative">
+        <button
+          type="button"
+          onClick={() => {
+            document.location = '/';
+          }}
+          className="peer bg-accent-02-light dark:bg-accent-02-dark hover:bg-accent-03-light dark:hover:bg-accent-03-dark flex cursor-pointer items-center justify-center rounded-full p-2.5 text-white transition-colors"
+          aria-label="New Chat"
+          title="New Chat"
+        >
+          <span className="sr-only">New Chat</span>
+          <svg
+            xmlns="http://www.w3.org/2000/svg"
+            className="h-5 w-5"
+            fill="none"
+            viewBox="0 0 24 24"
+            stroke="currentColor"
+            aria-hidden="true"
+          >
+            <path
+              strokeLinecap="round"
+              strokeLinejoin="round"
+              strokeWidth={2}
+              d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"
+            />
+          </svg>
+        </button>
+        <span className="pointer-events-none absolute top-full right-0 mt-1 rounded bg-gray-800 px-2 py-1 text-sm whitespace-nowrap text-white opacity-0 transition-opacity peer-hover:opacity-100">
+          New Chat
+        </span>
+      </div>
+    </div>
+  );
+}
+
+// Use React.memo with a custom comparison function to ensure the component only
+// re-renders when its props actually change
+export default memo(ChatHeaderContent, (prevProps, nextProps) => {
+  // Only re-render if title or onOpenSidebar changes
+  return prevProps.onOpenSidebar === nextProps.onOpenSidebar && prevProps.title === nextProps.title;
+}); 
\ No newline at end of file
diff --git a/app/components/ChatInput.tsx b/app/components/ChatInput.tsx
index 488099a..f1a7d19 100644
--- a/app/components/ChatInput.tsx
+++ b/app/components/ChatInput.tsx
@@ -1,5 +1,5 @@
 import type { ChangeEvent, KeyboardEvent, RefObject } from 'react';
-import { useEffect, memo } from 'react';
+import { useEffect, memo, useCallback } from 'react';
 
 interface ChatInputProps {
   value: string;
@@ -11,15 +11,19 @@ interface ChatInputProps {
 }
 
 function ChatInput({ value, onChange, onSend, onKeyDown, disabled, inputRef }: ChatInputProps) {
-  // Initial auto-resize
-  useEffect(() => {
-    // Auto-resize logic
+  // Auto-resize textarea function
+  const autoResizeTextarea = useCallback(() => {
     const textarea = inputRef.current;
     if (textarea) {
       textarea.style.height = 'auto';
       textarea.style.height = `${Math.max(60, textarea.scrollHeight)}px`;
     }
-  }, [value, inputRef]);
+  }, [inputRef]);
+
+  // Initial auto-resize
+  useEffect(() => {
+    autoResizeTextarea();
+  }, [value, autoResizeTextarea]);
 
   return (
     <div className="border-light-decorative-00 dark:border-dark-decorative-00 bg-light-background-01 dark:bg-dark-background-01 border-t px-4 py-3">
diff --git a/app/components/ChatInterface.tsx b/app/components/ChatInterface.tsx
new file mode 100644
index 0000000..42b90d4
--- /dev/null
+++ b/app/components/ChatInterface.tsx
@@ -0,0 +1,121 @@
+import { useState, useMemo, useCallback, useRef } from 'react';
+import type { ChangeEvent } from 'react';
+import type { ChatState } from '../types/chat';
+import SessionSidebar from './SessionSidebar';
+import MessageList from './MessageList';
+import ChatInput from './ChatInput';
+import QuickSuggestions from './QuickSuggestions';
+
+interface ChatInterfaceProps extends ChatState {
+  isSidebarVisible: boolean;
+  setIsSidebarVisible: (isVisible: boolean) => void;
+}
+
+function ChatInterface({
+  docs: messages,
+  input,
+  setInput,
+  isStreaming,
+  inputRef,
+  sendMessage,
+  sessionId,
+  title,
+  codeReady,
+  addScreenshot,
+  isSidebarVisible,
+  setIsSidebarVisible,
+}: ChatInterfaceProps) {
+  // State for UI transitions and sharing
+  const [isShrinking, setIsShrinking] = useState(false);
+  const [isExpanding, setIsExpanding] = useState(false);
+  const [selectedResponseId, setSelectedResponseId] = useState<string | null>(null);
+
+  // Sidebar visibility function
+  const closeSidebar = useCallback(() => {
+    setIsSidebarVisible(false);
+  }, [setIsSidebarVisible]);
+
+  // Function to handle input changes
+  const handleInputChange = useCallback(
+    (e: ChangeEvent<HTMLTextAreaElement>) => {
+      setInput(e.target.value);
+    },
+    [setInput]
+  );
+
+  // Function to handle keyboard events in textarea
+  const handleKeyDown = useCallback(
+    (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
+      if (e.key === 'Enter' && !e.shiftKey && !isStreaming) {
+        e.preventDefault();
+        sendMessage();
+      }
+    },
+    [isStreaming, sendMessage]
+  );
+
+  // Function to handle suggestion selection
+  const handleSelectSuggestion = useCallback(
+    (suggestion: string) => {
+      setInput(suggestion);
+
+      // Focus the input and position cursor at the end
+      setTimeout(() => {
+        if (inputRef.current) {
+          inputRef.current.focus();
+          // Move cursor to end of text
+          inputRef.current.selectionStart = inputRef.current.selectionEnd = suggestion.length;
+        }
+      }, 0);
+    },
+    [setInput, inputRef]
+  );
+
+  // Callback for setting the selected response ID
+  const handleSetSelectedResponseId = useCallback((id: string) => {
+    setSelectedResponseId(id);
+  }, []);
+
+  // Memoize the MessageList component to prevent unnecessary re-renders
+  const memoizedMessageList = useMemo(() => {
+    return (
+      <MessageList
+        messages={messages}
+        isStreaming={isStreaming}
+        isShrinking={isShrinking}
+        isExpanding={isExpanding}
+        setSelectedResponseId={handleSetSelectedResponseId}
+      />
+    );
+  }, [messages, isStreaming, isShrinking, isExpanding, handleSetSelectedResponseId]);
+
+  return (
+    <div className="flex h-full flex-col overflow-hidden bg-light-background-01 dark:bg-dark-background-01">
+      {messages.length > 0 ? (
+        <div className="flex-grow overflow-y-auto flex flex-col-reverse">
+          {memoizedMessageList}
+        </div>
+      ) : (
+        <div className="flex flex-col justify-between flex-grow">
+          <div className="flex-grow"></div>
+          <QuickSuggestions onSelectSuggestion={handleSelectSuggestion} />
+        </div>
+      )}
+      <ChatInput
+        value={input}
+        onChange={handleInputChange}
+        onKeyDown={handleKeyDown}
+        onSend={sendMessage}
+        disabled={isStreaming}
+        inputRef={inputRef}
+      />
+      <SessionSidebar 
+        isVisible={isSidebarVisible} 
+        onClose={closeSidebar} 
+        sessionId={sessionId || ''} 
+      />
+    </div>
+  );
+}
+
+export default ChatInterface;
diff --git a/app/components/Message.tsx b/app/components/Message.tsx
new file mode 100644
index 0000000..15b3545
--- /dev/null
+++ b/app/components/Message.tsx
@@ -0,0 +1,153 @@
+import { memo } from 'react';
+import ReactMarkdown from 'react-markdown';
+import StructuredMessage from './StructuredMessage';
+import type { ChatMessageDocument, AiChatMessageDocument, AiChatMessage } from '../types/chat';
+import { parseContent } from '~/utils/segmentParser';
+
+interface MessageProps {
+  message: ChatMessageDocument;
+  isShrinking: boolean;
+  isExpanding: boolean;
+  isStreaming: boolean;
+  setSelectedResponseId?: (id: string) => void;
+}
+
+// Helper function to get animation classes
+const getAnimationClasses = (isShrinking: boolean, isExpanding: boolean): string => {
+  return isShrinking ? 'animate-width-shrink' : isExpanding ? 'animate-width-expand' : '';
+};
+
+// AI Message component (simplified without animation handling)
+const AIMessage = memo(
+  ({ message, isStreaming }: { message: AiChatMessageDocument; isStreaming: boolean }) => {
+    const { segments } = parseContent(message.text);
+    return (
+      <div className="mb-4 flex flex-row justify-start px-4">
+        <div className="flex-shrink-0 mr-2">
+          <div className="h-8 w-8 rounded-full bg-accent-02-light dark:bg-accent-02-dark flex items-center justify-center shadow-sm">
+            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
+              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 18.657A8 8 0 016.343 7.343S7 9 9 10c0-2 .5-5 2.986-7C14 5 16.09 5.777 17.656 7.343A7.975 7.975 0 0120 13a7.975 7.975 0 01-2.343 5.657z" />
+              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.879 16.121A3 3 0 1012.015 11L11 14H9c0 .768.293 1.536.879 2.121z" />
+            </svg>
+          </div>
+        </div>
+        <div className="max-w-[85%] rounded-2xl bg-white px-5 py-3 text-gray-900 shadow-md dark:bg-gray-800 dark:text-gray-100">
+          <StructuredMessage segments={segments || []} isStreaming={isStreaming} />
+        </div>
+      </div>
+    );
+  },
+  (prevProps, nextProps) => {
+    // If either the message text or streaming state changed, we need to re-render
+    // Return false to signal React to re-render the component
+    if (
+      prevProps.message.text !== nextProps.message.text ||
+      prevProps.isStreaming !== nextProps.isStreaming
+    ) {
+      return false;
+    }
+    // Otherwise, skip re-render
+    return true;
+  }
+);
+
+// User Message component (simplified without animation handling)
+const UserMessage = memo(({ message }: { message: ChatMessageDocument }) => {
+  return (
+    <div className="mb-4 flex flex-row justify-end px-4">
+      <div className="max-w-[85%] rounded-2xl bg-gray-300 px-5 py-3 text-gray-800 shadow-md dark:bg-gray-700 dark:text-gray-100">
+        <div className="prose prose-sm dark:prose-invert max-w-none prose-ul:pl-5 prose-ul:list-disc prose-ol:pl-5 prose-ol:list-decimal prose-li:my-0">
+          <ReactMarkdown>{message.text}</ReactMarkdown>
+        </div>
+      </div>
+    </div>
+  );
+});
+
+// Main Message component that handles animation and decides which subcomponent to render
+const Message = memo(
+  ({ message, isShrinking, isExpanding, isStreaming, setSelectedResponseId }: MessageProps) => {
+    const handleClick = () => {
+      console.log('handleClick', message._id);
+      if (setSelectedResponseId && message._id) {
+        setSelectedResponseId(message._id);
+      }
+    };
+
+    return (
+      <div 
+        className={`transition-all duration-150 ease-in hover:opacity-95 ${getAnimationClasses(isShrinking, isExpanding)}`}
+        onClick={handleClick}
+      >
+        {message.type === 'ai' ? (
+          <AIMessage message={message as AiChatMessageDocument} isStreaming={isStreaming} />
+        ) : (
+          <UserMessage message={message} />
+        )}
+      </div>
+    );
+  },
+  (prevProps, nextProps) => {
+    // Check for message content changes
+    if (prevProps.message.text !== nextProps.message.text) {
+      return false; // Text changed, need to re-render
+    }
+
+    // Check for animation or streaming state changes
+    if (
+      prevProps.isShrinking !== nextProps.isShrinking ||
+      prevProps.isExpanding !== nextProps.isExpanding ||
+      prevProps.isStreaming !== nextProps.isStreaming
+    ) {
+      return false; // State changed, need to re-render
+    }
+
+    // Check if the setSelectedResponseId function reference changed
+    if (prevProps.setSelectedResponseId !== nextProps.setSelectedResponseId) {
+      return false; // Function reference changed, need to re-render
+    }
+
+    // If we get here, props are equal enough to skip re-render
+    return true;
+  }
+);
+
+export default Message;
+
+// Welcome screen component shown when no messages are present
+export const WelcomeScreen = memo(() => {
+  return (
+    <div className="text-accent-02 mx-auto max-w-2xl space-y-4 px-12 pt-8 text-center italic">
+      <p>
+        Quickly create React apps in your browser, no setup required. Apps are sharable, or eject
+        them to GitHub for easy deploys.{' '}
+        <a
+          href="https://github.com/fireproof-storage/ai-app-builder"
+          target="_blank"
+          rel="noopener noreferrer"
+          className="text-accent-00 hover:underline"
+        >
+          Fork and customize this app builder
+        </a>
+        , no backend required.
+      </p>
+
+      <div className="mt-6 border-t border-gray-200 pt-4 dark:border-gray-700">
+        <h3 className="py-2 text-lg font-semibold">About Fireproof</h3>
+        <p className="text-sm">
+          Fireproof enables secure saving and sharing of your data, providing encrypted live
+          synchronization and offline-first capabilities. Learn more about{' '}
+          <a
+            href="https://use-fireproof.com/"
+            target="_blank"
+            rel="noopener noreferrer"
+            className="text-accent-00 hover:underline"
+          >
+            Fireproof
+          </a>
+          .
+        </p>
+      </div>
+    </div>
+  );
+});
diff --git a/app/components/MessageList.tsx b/app/components/MessageList.tsx
index 328f67e..b5ff2b8 100644
--- a/app/components/MessageList.tsx
+++ b/app/components/MessageList.tsx
@@ -1,193 +1,74 @@
-import { useEffect, useRef, memo, useCallback, useMemo } from 'react';
-import type { ChatMessage } from '../types/chat';
-import ReactMarkdown from 'react-markdown';
+import { memo, useMemo } from 'react';
+import Message, { WelcomeScreen } from './Message';
+import type { ChatMessageDocument } from '../types/chat';
 
 interface MessageListProps {
-  messages: ChatMessage[];
-  isGenerating: boolean;
-  currentStreamedText: string;
+  messages: ChatMessageDocument[];
+  isStreaming: boolean;
   isShrinking?: boolean;
   isExpanding?: boolean;
+  setSelectedResponseId?: (id: string) => void;
 }
 
-// Shared utility function for rendering markdown content
-// Extracted outside the component to prevent recreation on each render
-const renderMarkdownContent = (text: string) => {
-  return (
-    <div className="prose prose-sm dark:prose-invert max-w-none">
-      <ReactMarkdown>{text}</ReactMarkdown>
-    </div>
-  );
-};
-
-// Individual message component to optimize rendering
-const Message = memo(
-  ({
-    message,
-    index,
-    isShrinking,
-    isExpanding,
-  }: {
-    message: ChatMessage;
-    index: number;
-    isShrinking: boolean;
-    isExpanding: boolean;
-  }) => {
-    return (
-      <div
-        className={`flex flex-col transition-all duration-500 ${isShrinking ? 'origin-top-left scale-0 opacity-0' : 'scale-100 opacity-100'
-          } ${isExpanding ? 'animate-bounce-in' : ''}`}
-        style={{
-          transitionDelay: isShrinking ? `${index * 50}ms` : '0ms',
-        }}
-      >
-        <div className={`flex ${message.type === 'user' ? 'justify-end' : 'justify-start'}`}>
-          {message.type === 'ai' && (
-            <div className="bg-light-background-00 dark:bg-dark-background-00 mr-2 flex h-8 w-8 items-center justify-center rounded-full">
-              <span className="text-light-primary dark:text-dark-primary text-sm font-medium">
-                AI
-              </span>
-            </div>
-          )}
-          <div
-            className={`message rounded-2xl p-3 ${message.type === 'user'
-                ? 'bg-accent-02-light dark:bg-accent-02-dark rounded-tr-sm text-white'
-                : 'bg-light-background-00 dark:bg-dark-decorative-00 text-light-primary dark:text-dark-primary rounded-tl-sm'
-              } max-w-[85%] shadow-sm`}
-          >
-            {renderMarkdownContent(message.text)}
-          </div>
-        </div>
-      </div>
-    );
-  }
-);
-
-// Optimized AI Typing component
-const AITyping = memo(({ currentStreamedText }: { currentStreamedText: string }) => {
-  return (
-    <div className="flex justify-start">
-      <div className="bg-light-background-00 dark:bg-dark-background-00 mr-2 flex h-8 w-8 items-center justify-center rounded-full">
-
-        <span className="text-light-primary dark:text-dark-primary text-sm font-medium">AI</span>
-      </div>
-      <div className="message bg-light-background-00 dark:bg-dark-background-00 text-light-primary dark:text-dark-primary max-w-[85%] rounded-2xl rounded-tl-sm p-3 shadow-sm">
-        {currentStreamedText ? (
-          <>
-            {renderMarkdownContent(currentStreamedText)}
-            <span className="bg-light-primary dark:bg-dark-primary ml-1 inline-block h-4 w-2 animate-pulse" />
-          </>
-        ) : (
-          <div className="flex items-center gap-2">
-            Thinking
-            <span className="flex gap-1">
-              <span className="bg-light-primary dark:bg-dark-primary h-1.5 w-1.5 animate-bounce rounded-full [animation-delay:-0.3s]" />
-              <span className="bg-light-primary dark:bg-dark-primary h-1.5 w-1.5 animate-bounce rounded-full [animation-delay:-0.15s]" />
-              <span className="bg-light-primary dark:bg-dark-primary h-1.5 w-1.5 animate-bounce rounded-full" />
-            </span>
-          </div>
-        )}
-      </div>
-    </div>
-  );
-});
-
 function MessageList({
   messages,
-  isGenerating,
-  currentStreamedText,
+  isStreaming,
   isShrinking = false,
   isExpanding = false,
+  setSelectedResponseId,
 }: MessageListProps) {
-  const messagesEndRef = useRef<HTMLDivElement>(null);
-
-  // Scroll to bottom when messages change
-  useEffect(() => {
-    try {
-      // Only run scrollIntoView if the element exists and the function is available
-      if (messagesEndRef.current && typeof messagesEndRef.current.scrollIntoView === 'function') {
-        messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
-      }
-    } catch (error) {
-      console.error('Error scrolling into view:', error);
-    }
-  }, [messages, currentStreamedText]);
-
-  // Memoize the message list to prevent unnecessary re-renders
   const messageElements = useMemo(() => {
-    return messages.map((msg, i) => (
-      <Message
-        key={`${msg.type}-${i}`}
-        message={msg}
-        index={i}
-        isShrinking={isShrinking}
-        isExpanding={isExpanding}
-      />
-    ));
-  }, [messages, isShrinking, isExpanding]);
+    return messages.map((msg, i) => {
+      return (
+        <Message
+          key={msg._id || 'streaming' + i}
+          message={msg}
+          isStreaming={isStreaming}
+          isShrinking={isShrinking}
+          isExpanding={isExpanding}
+          setSelectedResponseId={setSelectedResponseId}
+        />
+      );
+    });
+  }, [messages, isShrinking, isExpanding, isStreaming, setSelectedResponseId]);
 
   return (
     <div
-      className="messages bg-light-background-01 dark:bg-dark-background-01 flex-1 space-y-4 overflow-y-auto p-4"
-      style={{ maxHeight: 'calc(100vh - 140px)' }}
+      className={`flex-1 ${
+        isShrinking ? 'animate-width-shrink' : isExpanding ? 'animate-width-expand' : ''
+      }`}
     >
-      {messages.length === 0 && !isGenerating ? (
-        <div className="text-accent-02 mx-auto max-w-2xl space-y-4 px-12 pt-8 text-center italic">
-          <p>
-            Quickly create React apps in your browser, no setup required. Apps are sharable, or
-            eject them to GitHub for easy deploys.{' '}
-            <a
-              href="https://github.com/fireproof-storage/ai-app-builder"
-              target="_blank"
-              rel="noopener noreferrer"
-              className="text-accent-00 hover:underline"
-            >
-              Fork and customize this app builder
-            </a>
-            , no backend required.
-          </p>
-
-          <div className="mt-6 border-t border-gray-200 pt-4 dark:border-gray-700">
-            <h3 className="py-2 text-lg font-semibold">About Fireproof</h3>
-            <p className="text-sm">
-              Fireproof enables secure saving and sharing of your data, providing encrypted live
-              synchronization and offline-first capabilities. Learn more about{' '}
-              <a
-                href="https://use-fireproof.com/"
-                target="_blank"
-                rel="noopener noreferrer"
-                className="text-accent-00 hover:underline"
-              >
-                Fireproof
-              </a>
-              .
-            </p>
+      <div className="mx-auto flex min-h-full max-w-5xl flex-col py-4">
+        {messages.length === 0 && !isStreaming ? (
+          <WelcomeScreen />
+        ) : (
+          <div className="flex flex-col space-y-4">
+            {messageElements}
           </div>
-        </div>
-      ) : (
-        <>
-          {messageElements}
-          {isGenerating && <AITyping currentStreamedText={currentStreamedText} />}
-        </>
-      )}
-      <div ref={messagesEndRef} />
+        )}
+      </div>
     </div>
   );
 }
-
-// Export a memoized version of the component to prevent unnecessary re-renders
 export default memo(MessageList, (prevProps, nextProps) => {
-  // Simplified equality check focusing on the essential changed values
+  // Reference equality check for animation flags
+  const animationStateEqual =
+    prevProps.isStreaming === nextProps.isStreaming &&
+    prevProps.isShrinking === nextProps.isShrinking &&
+    prevProps.isExpanding === nextProps.isExpanding;
+
+  // Check if setSelectedResponseId changed
+  const setSelectedResponseIdEqual =
+    prevProps.setSelectedResponseId === nextProps.setSelectedResponseId;
+
+  // Content equality check for messages - must compare text content
   const messagesEqual =
-    prevProps.messages === nextProps.messages ||
-    (prevProps.messages.length === nextProps.messages.length &&
-      JSON.stringify(prevProps.messages) === JSON.stringify(nextProps.messages));
+    prevProps.messages.length === nextProps.messages.length &&
+    prevProps.messages.every((msg, i) => {
+      const nextMsg = nextProps.messages[i];
+      // Check message ID and text content
+      return msg._id === nextMsg._id && msg.text === nextMsg.text;
+    });
 
-  return (
-    messagesEqual &&
-    prevProps.isGenerating === nextProps.isGenerating &&
-    prevProps.currentStreamedText === nextProps.currentStreamedText &&
-    prevProps.isShrinking === nextProps.isShrinking &&
-    prevProps.isExpanding === nextProps.isExpanding
-  );
+  return animationStateEqual && messagesEqual && setSelectedResponseIdEqual;
 });
diff --git a/app/components/QuickSuggestions.tsx b/app/components/QuickSuggestions.tsx
index 3b85d25..80cbabe 100644
--- a/app/components/QuickSuggestions.tsx
+++ b/app/components/QuickSuggestions.tsx
@@ -39,7 +39,7 @@ function QuickSuggestions({ onSelectSuggestion }: QuickSuggestionsProps) {
   ];
 
   return (
-    <div className="bg-light-background-01 dark:bg-dark-background-01 px-4 py-3">
+    <div className="px-4 py-3">
       <div className="flex flex-wrap gap-2">
         {suggestions.map((suggestion, index) => (
           <button
diff --git a/app/components/ResultPreview/ResultPreview.tsx b/app/components/ResultPreview/ResultPreview.tsx
index eeba940..37d13c5 100644
--- a/app/components/ResultPreview/ResultPreview.tsx
+++ b/app/components/ResultPreview/ResultPreview.tsx
@@ -1,469 +1,145 @@
-import {
-  SandpackCodeEditor,
-  SandpackLayout,
-  SandpackPreview,
-  SandpackProvider,
-  useSandpack,
-} from '@codesandbox/sandpack-react';
-import { useState, useEffect, useCallback, useRef, useMemo } from 'react';
-import { sandpackDependencies } from '../../utils/versions';
+import { useState, useEffect, useRef, useMemo } from 'react';
+import type { ResultPreviewProps } from './ResultPreviewTypes';
+import type { SandpackFiles } from './ResultPreviewTypes';
+import { indexHtml, animationStyles } from './ResultPreviewTemplates';
+import { processCodeForDisplay } from './ResultPreviewUtils';
 import WelcomeScreen from './WelcomeScreen';
-import SandpackEventListener from './SandpackEventListener';
-import SandpackScrollController from './SandpackScrollController';
-
-interface ResultPreviewProps {
-  code: string;
-  streamingCode?: string;
-  isStreaming?: boolean;
-  dependencies?: Record<string, string>;
-  onShare?: () => void;
-  shareStatus?: string;
-  completedMessage?: string;
-  currentMessage?: { content: string };
-  currentStreamContent?: string;
-  onScreenshotCaptured?: (screenshotData: string) => void;
-  initialView?: 'code' | 'preview';
-  sessionId?: string;
-}
-
-const indexHtml = `<!DOCTYPE html>
-<html lang="en">
-  <head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <script src="https://cdn.tailwindcss.com"></script>
-    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
-    <script>
-      tailwind.config = {
-        darkMode: 'class',
-        theme: {
-          extend: {
-            colors: {
-              'light-primary': '#2C2C2C',
-              'light-secondary': '#2C2C2C',
-              'light-decorative-00': '#EBEAEA',
-              'light-decorative-01': '#E0DEDE',
-              'light-decorative-02': '#2C2C2C',
-              'light-background-00': '#FFFFFF',
-              'light-background-01': '#F5F5F5',
-              'light-background-02': '#F0F0F0',
-              'dark-primary': '#FFFFFF',
-              'dark-secondary': '#FFFFFF',
-              'dark-decorative-00': '#302F30',
-              'dark-decorative-01': '#414141',
-              'dark-decorative-02': '#FFFFFF',
-              'dark-background-00': '#171616',
-              'dark-background-01': '#201F20',
-              'dark-background-02': '#201F20',
-              'accent-00-light': '#F9A100',
-              'accent-01-light': '#F58709',
-              'accent-02-light': '#F16C12',
-              'accent-03-light': '#EE521C',
-              'accent-00-dark': '#FFAA0F',
-              'accent-01-dark': '#FF8F0F',
-              'accent-02-dark': '#FF7119',
-              'accent-03-dark': '#FF612A',
-            }
-          }
-        }
-      }
-
-      function captureScreenshot() {
-        html2canvas(document.body).then(canvas => {
-          const dataURI = canvas.toDataURL();
-          window.parent.postMessage({ screenshot: dataURI }, '*');
-        });
-      }
-      
-      // Automatically capture screenshot when page is fully loaded
-      window.addEventListener('load', function() {
-        // Wait a short moment for any final rendering
-        setTimeout(captureScreenshot, 500);
-      });
-    </script>
-  </head>
-  <body>
-    <div id="root"></div>
-    <script type="module" src="/index.jsx"></script>
-  </body>
-</html>`;
-
-const defaultCode = '';
+import SandpackContent from './SandpackContent';
 
 function ResultPreview({
   code,
-  streamingCode = '',
-  isStreaming = false,
   dependencies = {},
-  onShare,
-  shareStatus,
-  completedMessage,
-  currentMessage,
-  currentStreamContent,
   onScreenshotCaptured,
-  initialView = 'preview',
   sessionId,
+  isStreaming = false,
+  codeReady = false,
+  activeView,
+  setActiveView,
+  onPreviewLoaded,
 }: ResultPreviewProps) {
-  const [activeView, setActiveView] = useState<'preview' | 'code'>(initialView);
-  const [displayCode, setDisplayCode] = useState(code || defaultCode);
-  const [appStartedCount, setAppStartedCount] = useState(0);
   const [bundlingComplete, setBundlingComplete] = useState(true);
-  const justFinishedStreamingRef = useRef(false);
-  const [showWelcome, setShowWelcome] = useState(true);
-  const [isDarkMode, setIsDarkMode] = useState(false);
-  const codeEditorRef = useRef<HTMLDivElement>(null);
-  const [lockCodeView, setLockCodeView] = useState(false);
-  const filesRef = useRef({
-    '/index.html': {
-      code: indexHtml,
-      hidden: true,
-    },
-    '/App.jsx': {
-      code: code || defaultCode,
-      active: true,
-    },
-  });
+  const [previewReady, setPreviewReady] = useState(false);
+  const isStreamingRef = useRef(isStreaming);
+  const hasGeneratedStreamingKeyRef = useRef(false);
+  const streamingKeyRef = useRef<string>('');
 
-  useEffect(() => {
-    const prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
-    setIsDarkMode(prefersDarkMode);
+  const filesRef = useRef<SandpackFiles>({});
+  const showWelcome = !isStreaming && (!code || code.length === 0);
 
-    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
-    const handleChange = (e: MediaQueryListEvent) => {
-      setIsDarkMode(e.matches);
-    };
+  // Track streaming state changes to reset key generation only when streaming starts/stops
+  useEffect(() => {
+    if (isStreaming !== isStreamingRef.current) {
+      isStreamingRef.current = isStreaming;
+      
+      // Reset streaming key when streaming stops
+      if (!isStreaming) {
+        hasGeneratedStreamingKeyRef.current = false;
+      }
+    }
+  }, [isStreaming]);
 
-    mediaQuery.addEventListener('change', handleChange);
-    return () => mediaQuery.removeEventListener('change', handleChange);
-  }, []);
+  const sandpackKey = useMemo(() => {
+    if (showWelcome) return `${sessionId || 'default'}-welcome`;
+    
+    // During streaming, use a stable key that doesn't include the changing code
+    if (isStreaming) {
+      // Only generate a new streaming key once per streaming session
+      if (!hasGeneratedStreamingKeyRef.current) {
+        // Use timestamp to ensure unique key between different streaming sessions
+        streamingKeyRef.current = `${sessionId || 'default'}-streaming-${Date.now()}`;
+        hasGeneratedStreamingKeyRef.current = true;
+      }
+      return streamingKeyRef.current;
+    }
+    
+    // For non-streaming mode, we can include the code in the key (content is stable)
+    // But to prevent the key from being too long, just use a hash of the code
+    return `${sessionId || 'default'}-static-${codeReady}-${code.length}-${Date.now()}`;
+  }, [sessionId, isStreaming, codeReady, showWelcome, code.length]);
 
   useEffect(() => {
-    const handleMessage = (event: MessageEvent) => {
-      if (event.data && event.data.screenshot) {
-        const screenshotData = event.data.screenshot;
+    if (isStreaming) {
+      // Reset to code view when streaming starts
+      setActiveView('code');
+    }
+  }, [isStreaming, setActiveView]);
 
-        if (onScreenshotCaptured) {
-          onScreenshotCaptured(screenshotData);
+  useEffect(() => {
+    const handleMessage = ({ data }: MessageEvent) => {
+      if (data) {
+        if (data.type === 'preview-loaded') {
+          setPreviewReady(true);
+          // Automatically switch to preview view when it's ready
+          setActiveView('preview');
+          // Notify parent component that preview is loaded
+          onPreviewLoaded();
+        } else if (data.type === 'screenshot' && data.data) {
+          console.log('ResultPreview: Received screenshot');
+          if (onScreenshotCaptured) {
+            onScreenshotCaptured(data.data);
+          }
         }
       }
     };
 
     window.addEventListener('message', handleMessage);
-    return () => window.removeEventListener('message', handleMessage);
-  }, [onScreenshotCaptured]);
+    return () => {
+      window.removeEventListener('message', handleMessage);
+    };
+  }, [onScreenshotCaptured, setActiveView, onPreviewLoaded]);
 
   useEffect(() => {
-    if (!isStreaming) {
-      const codeWithWhitespace =
-        cleanCodeBeforeImport(code || defaultCode) +
-        '\n\n\n\n\n\n\n\n\n\n' +
-        '\n\n\n\n\n\n\n\n\n\n' +
-        '\n';
-      setDisplayCode(codeWithWhitespace);
+    if (!showWelcome) {
+      const processedCode = processCodeForDisplay(code);
+      filesRef.current = {
+        ...filesRef.current,
+        '/App.jsx': {
+          code: processedCode,
+          active: true,
+        },
+      };
+    }
+  }, [code, showWelcome]);
 
+  const previewArea = showWelcome ? (
+    <div className="h-full">
+      <WelcomeScreen />
+    </div>
+  ) : (
+    (() => {
+      // Initialize files content here, right before SandpackContent is rendered
       filesRef.current = {
         '/index.html': {
           code: indexHtml,
           hidden: true,
         },
         '/App.jsx': {
-          code: codeWithWhitespace,
+          code: processCodeForDisplay(code),
           active: true,
         },
       };
 
-      if (code) {
-        setShowWelcome(false);
-      }
-    }
-  }, [code, isStreaming, sessionId]);
-
-  useEffect(() => {
-    if (isStreaming) {
-      if (streamingCode) {
-        const codeWithWhitespace = cleanCodeBeforeImport(streamingCode) + '\n\n\n\n\n\n\n\n\n\n';
-        setDisplayCode(codeWithWhitespace);
-
-        filesRef.current = {
-          ...filesRef.current,
-          '/App.jsx': {
-            code: codeWithWhitespace,
-            active: true,
-          },
-        };
-
-        setShowWelcome(false);
-        setActiveView('code');
-        setLockCodeView(true);
-      }
-    }
-  }, [streamingCode, isStreaming]);
-
-  useEffect(() => {
-    if (!isStreaming) {
-      setLockCodeView(false);
-    }
-  }, [isStreaming]);
-
-  useEffect(() => {
-    if (isStreaming && streamingCode) {
-      justFinishedStreamingRef.current = true;
-    }
-  }, [isStreaming, streamingCode]);
-
-  useEffect(() => {
-    if (bundlingComplete) {
-      justFinishedStreamingRef.current = false;
-    }
-  }, [bundlingComplete]);
-
-  const shouldSpin = !isStreaming && justFinishedStreamingRef.current && !bundlingComplete;
-
-  const spinningIconClass = shouldSpin ? 'animate-spin-slow' : '';
-
-  // Memoize the dependencies for Sandpack
-  const depsString = useMemo(() => JSON.stringify(dependencies), [dependencies]);
-
-  const sandpackDependencies = useMemo(() => {
-    // Ensure use-fireproof is included in the dependencies
-    return {
-      'use-fireproof': '0.20.0-dev-preview-52',
-      ...dependencies,
-    };
-  }, [depsString]);
-
-  // Create a unique key for SandpackProvider that changes when sessionId or code changes
-  const sandpackKey = useMemo(() => {
-    // Using Date.now() causes unnecessary remounts on every render
-    // Instead, use the actual content that should trigger a remount
-    const key = `${sessionId || 'default'}-${isStreaming ? 'streaming' : 'static'}-${code.length}`;
-    return key;
-  }, [sessionId, isStreaming, code]);
+      return (
+        <SandpackContent
+          activeView={activeView}
+          filesContent={filesRef.current}
+          isStreaming={!codeReady}
+          codeReady={codeReady}
+          sandpackKey={sandpackKey}
+          setActiveView={setActiveView}
+          setBundlingComplete={setBundlingComplete}
+          dependencies={dependencies}
+        />
+      );
+    })()
+  );
 
   return (
     <div className="h-full" style={{ overflow: 'hidden' }}>
-      <style>
-        {`
-          @keyframes spin-slow {
-            from {
-              transform: rotate(0deg);
-            }
-            to {
-              transform: rotate(360deg);
-            }
-          }
-          .animate-spin-slow {
-            animation: spin-slow 1s linear infinite;
-          }
-        `}
-      </style>
-      <div className="border-light-decorative-00 dark:border-dark-decorative-00 bg-light-background-00 dark:bg-dark-background-00 flex min-h-[4rem] items-center justify-between border-b px-6 py-4">
-        {!showWelcome ? (
-          <div className="bg-light-decorative-00 dark:bg-dark-decorative-00 flex space-x-1 rounded-lg p-1 shadow-sm">
-            <button
-              type="button"
-              onClick={() => setActiveView('preview')}
-              className={`flex items-center space-x-1.5 rounded-md px-4 py-1.5 text-sm font-medium transition-colors ${
-                activeView === 'preview'
-                  ? 'bg-light-background-00 dark:bg-dark-background-00 text-light-primary dark:text-dark-primary shadow-sm'
-                  : 'text-light-primary dark:text-dark-primary hover:bg-light-decorative-01 dark:hover:bg-dark-decorative-01'
-              }`}
-              aria-label="Switch to preview"
-            >
-              <svg
-                xmlns="http://www.w3.org/2000/svg"
-                className={`h-4 w-4 ${spinningIconClass}`}
-                fill="none"
-                viewBox="0 0 24 24"
-                stroke="currentColor"
-              >
-                <title>Preview icon</title>
-                <path
-                  strokeLinecap="round"
-                  strokeLinejoin="round"
-                  strokeWidth={2}
-                  d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
-                />
-                <path
-                  strokeLinecap="round"
-                  strokeLinejoin="round"
-                  strokeWidth={2}
-                  d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
-                />
-              </svg>
-              <span>Preview</span>
-            </button>
-            <button
-              type="button"
-              onClick={() => {
-                setActiveView('code');
-                setShowWelcome(false);
-              }}
-              className={`flex items-center space-x-1.5 rounded-md px-4 py-1.5 text-sm font-medium transition-colors ${
-                activeView === 'code'
-                  ? 'bg-light-background-00 dark:bg-dark-background-00 text-light-primary dark:text-dark-primary shadow-sm'
-                  : 'text-light-primary dark:text-dark-primary hover:bg-light-decorative-01 dark:hover:bg-dark-decorative-01'
-              }`}
-              aria-label="Switch to code editor"
-            >
-              <svg
-                xmlns="http://www.w3.org/2000/svg"
-                className="h-4 w-4"
-                fill="none"
-                viewBox="0 0 24 24"
-                stroke="currentColor"
-              >
-                <title>Code icon</title>
-                <path
-                  strokeLinecap="round"
-                  strokeLinejoin="round"
-                  strokeWidth={2}
-                  d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"
-                />
-              </svg>
-              <span>Code</span>
-            </button>
-          </div>
-        ) : (
-          <div className="h-10"></div>
-        )}
-
-        {isStreaming && (
-          <div className="text-accent-03-light dark:text-accent-03-dark ml-2 w-10 animate-pulse text-sm">
-            {streamingCode.split('\n').length > 2 ? streamingCode.split('\n').length : ''}
-          </div>
-        )}
-
-        {onShare ? (
-          !showWelcome && (
-            <div className="flex items-center gap-2">
-              {shareStatus && (
-                <div className="animate-fade-in bg-accent-00-light dark:bg-accent-00-dark text-light-primary dark:text-dark-primary rounded-lg px-3 py-1 text-sm">
-                  {shareStatus}
-                </div>
-              )}
-              <div className="bg-light-decorative-00 dark:bg-dark-decorative-00 flex space-x-1 rounded-lg p-1 shadow-sm">
-                <button
-                  type="button"
-                  onClick={onShare}
-                  className="text-light-primary dark:text-dark-primary hover:bg-light-decorative-01 dark:hover:bg-dark-decorative-01 flex items-center space-x-1.5 rounded-md px-4 py-1.5 text-sm font-medium transition-colors"
-                  aria-label="Share app"
-                >
-                  <svg
-                    xmlns="http://www.w3.org/2000/svg"
-                    className="h-4 w-4"
-                    fill="none"
-                    viewBox="0 0 24 24"
-                    stroke="currentColor"
-                  >
-                    <title>Share icon</title>
-                    <path
-                      strokeLinecap="round"
-                      strokeLinejoin="round"
-                      strokeWidth={2}
-                      d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"
-                    />
-                  </svg>
-                  <span>Share</span>
-                </button>
-              </div>
-            </div>
-          )
-        ) : (
-          <div className="h-10 w-10"></div>
-        )}
-      </div>
-
-      {showWelcome ? (
-        <div className="h-full" style={{ height: 'calc(100vh - 49px)' }}>
-          <WelcomeScreen />
-        </div>
-      ) : (
-        <div data-testid="sandpack-provider">
-          <SandpackProvider
-            key={sandpackKey}
-            template="vite-react"
-            options={{
-              externalResources: ['https://cdn.tailwindcss.com'],
-              classes: { 'sp-wrapper': 'h-full' },
-            }}
-            customSetup={{
-              dependencies: {
-                'use-fireproof': '0.20.0-dev-preview-52',
-                ...(dependencies || {}),
-              },
-            }}
-            files={filesRef.current}
-            theme={isDarkMode ? 'dark' : 'light'}
-          >
-            <SandpackEventListener
-              setActiveView={(view) => {
-                setActiveView(view);
-              }}
-              setBundlingComplete={setBundlingComplete}
-              isStreaming={isStreaming}
-            />
-            {isStreaming && <SandpackScrollController isStreaming={isStreaming} />}
-            <SandpackLayout className="h-full" style={{ height: 'calc(100vh - 49px)' }}>
-              <div
-                style={{
-                  display: activeView === 'preview' ? 'block' : 'none',
-                  height: '100%',
-                  width: '100%',
-                }}
-              >
-                <SandpackPreview
-                  showNavigator={false}
-                  showOpenInCodeSandbox={false}
-                  showRefreshButton={true}
-                  showRestartButton={false}
-                  showOpenNewtab={false}
-                  className="h-full w-full"
-                  style={{ height: '100%' }}
-                />
-              </div>
-              <div
-                style={{
-                  display: activeView === 'code' ? 'block' : 'none',
-                  height: '100%',
-                  width: '100%',
-                }}
-                ref={codeEditorRef}
-              >
-                <SandpackCodeEditor
-                  style={{ height: '100%' }}
-                  showLineNumbers={false}
-                  wrapContent
-                  showInlineErrors
-                />
-              </div>
-            </SandpackLayout>
-          </SandpackProvider>
-        </div>
-      )}
-
-      <div className="result-content">
-        {!showWelcome && (
-          <button
-            data-testid="copy-button"
-            onClick={() => navigator.clipboard.writeText(displayCode)}
-            className="text-light-primary dark:text-dark-primary hover:bg-light-decorative-01 dark:hover:bg-dark-decorative-01 rounded-md px-4 py-1.5 text-sm font-medium transition-colors"
-          >
-            Copy to Clipboard
-          </button>
-        )}
-        {streamingCode ? (
-          <div>{currentStreamContent}</div>
-        ) : (
-          <div>{completedMessage || currentMessage?.content || ''}</div>
-        )}
-      </div>
+      <style>{animationStyles}</style>
+      {previewArea}
     </div>
   );
 }
 
-function cleanCodeBeforeImport(codeString: string) {
-  return codeString.replace(/^[\s\S]*?(import|export)/, '$1');
-}
-
 export default ResultPreview;
diff --git a/app/components/ResultPreview/ResultPreviewHeaderContent.tsx b/app/components/ResultPreview/ResultPreviewHeaderContent.tsx
new file mode 100644
index 0000000..f5a4f2d
--- /dev/null
+++ b/app/components/ResultPreview/ResultPreviewHeaderContent.tsx
@@ -0,0 +1,155 @@
+import React, { useState } from 'react';
+import { copyToClipboard, encodeStateToUrl } from '../../utils/sharing';
+
+interface ResultPreviewHeaderContentProps {
+  previewReady: boolean;
+  activeView: 'preview' | 'code';
+  setActiveView: (view: 'preview' | 'code') => void;
+  bundlingComplete: boolean;
+  isStreaming: boolean;
+  code: string;
+  dependencies?: Record<string, string>;
+}
+
+const ResultPreviewHeaderContent: React.FC<ResultPreviewHeaderContentProps> = ({
+  previewReady,
+  activeView,
+  setActiveView,
+  bundlingComplete,
+  isStreaming,
+  code,
+  dependencies = {},
+}) => {
+  const [shareStatus, setShareStatus] = useState<string>('');
+
+  function handleShare() {
+    if (!code) {
+      alert('Generate an app first before sharing!');
+      return;
+    }
+
+    const encoded = encodeStateToUrl(code, dependencies);
+    if (encoded) {
+      copyToClipboard(`${window.location.origin}/shared?state=${encoded}`);
+      setShareStatus('Share URL copied to clipboard!');
+      setTimeout(() => {
+        setShareStatus('');
+      }, 3000);
+    }
+  }
+
+  const showSwitcher = code.length > 0;
+
+  return (
+    <div className="flex h-full w-full items-center justify-between px-6 py-4">
+      {showSwitcher ? (
+        <div className="bg-light-decorative-00 dark:bg-dark-decorative-00 flex space-x-1 rounded-lg p-1 shadow-sm">
+          <button
+            type="button"
+            disabled={!previewReady}
+            onClick={() => setActiveView('preview')}
+            className={`flex items-center space-x-1.5 rounded-md px-4 py-1.5 text-sm font-medium transition-colors ${
+              activeView === 'preview'
+                ? 'bg-light-background-00 dark:bg-dark-background-00 text-light-primary dark:text-dark-primary shadow-sm'
+                : 'text-light-primary dark:text-dark-primary' +
+                  (previewReady
+                    ? ' hover:bg-light-decorative-01 dark:hover:bg-dark-decorative-01'
+                    : ' cursor-not-allowed opacity-50')
+            }`}
+            aria-label="Switch to preview"
+          >
+            <svg
+              xmlns="http://www.w3.org/2000/svg"
+              className={`h-4 w-4 ${bundlingComplete && !previewReady ? 'animate-spin-slow' : ''}`}
+              fill="none"
+              viewBox="0 0 24 24"
+              stroke="currentColor"
+            >
+              <title>Preview icon</title>
+              <path
+                strokeLinecap="round"
+                strokeLinejoin="round"
+                strokeWidth={2}
+                d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
+              />
+              <path
+                strokeLinecap="round"
+                strokeLinejoin="round"
+                strokeWidth={2}
+                d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
+              />
+            </svg>
+            <span>Preview</span>
+          </button>
+          <button
+            type="button"
+            onClick={() => {
+              setActiveView('code');
+            }}
+            className={`flex items-center space-x-1.5 rounded-md px-4 py-1.5 text-sm font-medium transition-colors ${
+              activeView === 'code'
+                ? 'bg-light-background-00 dark:bg-dark-background-00 text-light-primary dark:text-dark-primary shadow-sm'
+                : 'text-light-primary dark:text-dark-primary hover:bg-light-decorative-01 dark:hover:bg-dark-decorative-01'
+            }`}
+            aria-label="Switch to code editor"
+          >
+            <svg
+              xmlns="http://www.w3.org/2000/svg"
+              className="h-4 w-4"
+              fill="none"
+              viewBox="0 0 24 24"
+              stroke="currentColor"
+            >
+              <title>Code icon</title>
+              <path
+                strokeLinecap="round"
+                strokeLinejoin="round"
+                strokeWidth={2}
+                d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"
+              />
+            </svg>
+            <span>Code</span>
+          </button>
+        </div>
+      ) : (
+        <div className="h-10"></div>
+      )}
+      {code ? (
+        <div className="flex items-center gap-2">
+          {shareStatus && (
+            <span className="text-sm text-green-600 dark:text-green-400">{shareStatus}</span>
+          )}
+          <div className="bg-light-decorative-00 dark:bg-dark-decorative-00 flex space-x-1 rounded-lg p-1 shadow-sm">
+            <button
+              type="button"
+              onClick={handleShare}
+              className="text-light-primary dark:text-dark-primary hover:bg-light-decorative-01 dark:hover:bg-dark-decorative-01 flex items-center space-x-1.5 rounded-md px-4 py-1.5 text-sm font-medium transition-colors"
+              aria-label="Share app"
+            >
+              <svg
+                xmlns="http://www.w3.org/2000/svg"
+                className="h-4 w-4"
+                fill="none"
+                viewBox="0 0 24 24"
+                stroke="currentColor"
+              >
+                <title>Share icon</title>
+                <path
+                  strokeLinecap="round"
+                  strokeLinejoin="round"
+                  strokeWidth={2}
+                  d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"
+                />
+              </svg>
+              <span>Share</span>
+            </button>
+          </div>
+        </div>
+      ) : (
+        <div className="h-10 w-10"></div>
+      )}
+    </div>
+  );
+};
+
+export default ResultPreviewHeaderContent; 
\ No newline at end of file
diff --git a/app/components/ResultPreview/ResultPreviewTemplates.ts b/app/components/ResultPreview/ResultPreviewTemplates.ts
new file mode 100644
index 0000000..561dbc9
--- /dev/null
+++ b/app/components/ResultPreview/ResultPreviewTemplates.ts
@@ -0,0 +1,89 @@
+export const indexHtml = `<!DOCTYPE html>
+<html lang="en">
+  <head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <script src="https://cdn.tailwindcss.com"></script>
+    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
+    <script>
+      tailwind.config = {
+        darkMode: 'class',
+        theme: {
+          extend: {
+            colors: {
+              'light-primary': '#2C2C2C',
+              'light-secondary': '#2C2C2C',
+              'light-decorative-00': '#EBEAEA',
+              'light-decorative-01': '#E0DEDE',
+              'light-decorative-02': '#2C2C2C',
+              'light-background-00': '#FFFFFF',
+              'light-background-01': '#F5F5F5',
+              'light-background-02': '#F0F0F0',
+              'dark-primary': '#FFFFFF',
+              'dark-secondary': '#FFFFFF',
+              'dark-decorative-00': '#302F30',
+              'dark-decorative-01': '#414141',
+              'dark-decorative-02': '#FFFFFF',
+              'dark-background-00': '#171616',
+              'dark-background-01': '#201F20',
+              'dark-background-02': '#201F20',
+              'accent-00-light': '#F9A100',
+              'accent-01-light': '#F58709',
+              'accent-02-light': '#F16C12',
+              'accent-03-light': '#EE521C',
+              'accent-00-dark': '#FFAA0F',
+              'accent-01-dark': '#FF8F0F',
+              'accent-02-dark': '#FF7119',
+              'accent-03-dark': '#FF612A',
+            }
+          }
+        }
+      }
+
+      function captureScreenshot() {
+        html2canvas(document.body).then(canvas => {
+          const dataURI = canvas.toDataURL();
+          window.parent.postMessage({ type: 'screenshot', data: dataURI }, '*');
+        });
+      }
+
+      function pageIsLoaded() {
+        window.parent.postMessage({ type: 'preview-loaded' }, '*');
+        setTimeout(captureScreenshot, 100);
+      }
+
+      window.addEventListener('DOMContentLoaded', function() {        
+        const rootElement = document.getElementById('root');
+        if (rootElement) {
+          const observer = new MutationObserver(function(mutations) {
+            if (rootElement.children.length > 0) {
+              pageIsLoaded();
+              observer.disconnect();
+            }
+          });          
+          observer.observe(rootElement, { childList: true, subtree: true });
+        } else {
+          pageIsLoaded();
+        }
+      });
+    </script>
+  </head>
+  <body style="margin-bottom: 20px;">
+    <div id="root"></div>
+    <script type="module" src="/index.jsx"></script>
+  </body>
+</html>`;
+
+export const animationStyles = `
+  @keyframes spin-slow {
+    from {
+      transform: rotate(0deg);
+    }
+    to {
+      transform: rotate(360deg);
+    }
+  }
+  .animate-spin-slow {
+    animation: spin-slow 1s linear infinite;
+  }
+`;
diff --git a/app/components/ResultPreview/ResultPreviewToolbar.tsx b/app/components/ResultPreview/ResultPreviewToolbar.tsx
new file mode 100644
index 0000000..a3d8ac3
--- /dev/null
+++ b/app/components/ResultPreview/ResultPreviewToolbar.tsx
@@ -0,0 +1,155 @@
+import React, { useState } from 'react';
+import { copyToClipboard, encodeStateToUrl } from '../../utils/sharing';
+
+interface ResultPreviewToolbarProps {
+  previewReady: boolean;
+  activeView: 'preview' | 'code';
+  setActiveView: (view: 'preview' | 'code') => void;
+  bundlingComplete: boolean;
+  isStreaming: boolean;
+  code: string;
+  dependencies?: Record<string, string>;
+}
+
+const ResultPreviewToolbar: React.FC<ResultPreviewToolbarProps> = ({
+  previewReady,
+  activeView,
+  setActiveView,
+  bundlingComplete,
+  isStreaming,
+  code,
+  dependencies = {},
+}) => {
+  const [shareStatus, setShareStatus] = useState<string>('');
+
+  function handleShare() {
+    if (!code) {
+      alert('Generate an app first before sharing!');
+      return;
+    }
+
+    const encoded = encodeStateToUrl(code, dependencies);
+    if (encoded) {
+      copyToClipboard(`${window.location.origin}/shared?state=${encoded}`);
+      setShareStatus('Share URL copied to clipboard!');
+      setTimeout(() => {
+        setShareStatus('');
+      }, 3000);
+    }
+  }
+
+  const showSwitcher = code.length > 0;
+
+  return (
+    <div className="border-light-decorative-00 dark:border-dark-decorative-00 bg-light-background-00 dark:bg-dark-background-00 flex h-[4rem] items-center justify-between border-b px-6 py-4">
+      {showSwitcher ? (
+        <div className="bg-light-decorative-00 dark:bg-dark-decorative-00 flex space-x-1 rounded-lg p-1 shadow-sm">
+          <button
+            type="button"
+            disabled={!previewReady}
+            onClick={() => setActiveView('preview')}
+            className={`flex items-center space-x-1.5 rounded-md px-4 py-1.5 text-sm font-medium transition-colors ${
+              activeView === 'preview'
+                ? 'bg-light-background-00 dark:bg-dark-background-00 text-light-primary dark:text-dark-primary shadow-sm'
+                : 'text-light-primary dark:text-dark-primary' +
+                  (previewReady
+                    ? ' hover:bg-light-decorative-01 dark:hover:bg-dark-decorative-01'
+                    : ' cursor-not-allowed opacity-50')
+            }`}
+            aria-label="Switch to preview"
+          >
+            <svg
+              xmlns="http://www.w3.org/2000/svg"
+              className={`h-4 w-4 ${bundlingComplete && !previewReady ? 'animate-spin-slow' : ''}`}
+              fill="none"
+              viewBox="0 0 24 24"
+              stroke="currentColor"
+            >
+              <title>Preview icon</title>
+              <path
+                strokeLinecap="round"
+                strokeLinejoin="round"
+                strokeWidth={2}
+                d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
+              />
+              <path
+                strokeLinecap="round"
+                strokeLinejoin="round"
+                strokeWidth={2}
+                d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
+              />
+            </svg>
+            <span>Preview</span>
+          </button>
+          <button
+            type="button"
+            onClick={() => {
+              setActiveView('code');
+            }}
+            className={`flex items-center space-x-1.5 rounded-md px-4 py-1.5 text-sm font-medium transition-colors ${
+              activeView === 'code'
+                ? 'bg-light-background-00 dark:bg-dark-background-00 text-light-primary dark:text-dark-primary shadow-sm'
+                : 'text-light-primary dark:text-dark-primary hover:bg-light-decorative-01 dark:hover:bg-dark-decorative-01'
+            }`}
+            aria-label="Switch to code editor"
+          >
+            <svg
+              xmlns="http://www.w3.org/2000/svg"
+              className="h-4 w-4"
+              fill="none"
+              viewBox="0 0 24 24"
+              stroke="currentColor"
+            >
+              <title>Code icon</title>
+              <path
+                strokeLinecap="round"
+                strokeLinejoin="round"
+                strokeWidth={2}
+                d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"
+              />
+            </svg>
+            <span>Code</span>
+          </button>
+        </div>
+      ) : (
+        <div className="h-10"></div>
+      )}
+      {code ? (
+        <div className="flex items-center gap-2">
+          {shareStatus && (
+            <span className="text-sm text-green-600 dark:text-green-400">{shareStatus}</span>
+          )}
+          <div className="bg-light-decorative-00 dark:bg-dark-decorative-00 flex space-x-1 rounded-lg p-1 shadow-sm">
+            <button
+              type="button"
+              onClick={handleShare}
+              className="text-light-primary dark:text-dark-primary hover:bg-light-decorative-01 dark:hover:bg-dark-decorative-01 flex items-center space-x-1.5 rounded-md px-4 py-1.5 text-sm font-medium transition-colors"
+              aria-label="Share app"
+            >
+              <svg
+                xmlns="http://www.w3.org/2000/svg"
+                className="h-4 w-4"
+                fill="none"
+                viewBox="0 0 24 24"
+                stroke="currentColor"
+              >
+                <title>Share icon</title>
+                <path
+                  strokeLinecap="round"
+                  strokeLinejoin="round"
+                  strokeWidth={2}
+                  d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"
+                />
+              </svg>
+              <span>Share</span>
+            </button>
+          </div>
+        </div>
+      ) : (
+        <div className="h-10 w-10"></div>
+      )}
+    </div>
+  );
+};
+
+export default ResultPreviewToolbar;
diff --git a/app/components/ResultPreview/ResultPreviewTypes.ts b/app/components/ResultPreview/ResultPreviewTypes.ts
new file mode 100644
index 0000000..d436bcd
--- /dev/null
+++ b/app/components/ResultPreview/ResultPreviewTypes.ts
@@ -0,0 +1,19 @@
+export interface ResultPreviewProps {
+  code: string;
+  dependencies?: Record<string, string>;
+  onScreenshotCaptured?: (screenshotData: string) => void;
+  sessionId?: string;
+  isStreaming?: boolean;
+  codeReady?: boolean;
+  activeView: 'code' | 'preview';
+  setActiveView: (view: 'code' | 'preview') => void;
+  onPreviewLoaded: () => void;
+}
+
+export type SandpackFiles = {
+  [path: string]: {
+    code: string;
+    hidden?: boolean;
+    active?: boolean;
+  };
+};
diff --git a/app/components/ResultPreview/ResultPreviewUtils.ts b/app/components/ResultPreview/ResultPreviewUtils.ts
new file mode 100644
index 0000000..ae38fe6
--- /dev/null
+++ b/app/components/ResultPreview/ResultPreviewUtils.ts
@@ -0,0 +1,14 @@
+/**
+ * Cleans the code string by removing any content before the first import or export statement
+ */
+export function cleanCodeBeforeImport(codeString: string): string {
+  return codeString;
+  // return codeString.replace(/^[\s\S]*?(import|export)/, '$1');
+}
+
+/**
+ * Processes the code for display in the Sandpack editor
+ */
+export function processCodeForDisplay(sourceCode: string): string {
+  return cleanCodeBeforeImport(sourceCode) + '\n\n\n\n\n\n\n\n\n\n';
+}
diff --git a/app/components/ResultPreview/SandpackContent.tsx b/app/components/ResultPreview/SandpackContent.tsx
new file mode 100644
index 0000000..72a5a1b
--- /dev/null
+++ b/app/components/ResultPreview/SandpackContent.tsx
@@ -0,0 +1,143 @@
+import React, { useRef, useState, useEffect } from 'react';
+import {
+  SandpackCodeEditor,
+  SandpackLayout,
+  SandpackPreview,
+  SandpackProvider,
+} from '@codesandbox/sandpack-react';
+import SandpackScrollController from './SandpackScrollController';
+import type { SandpackFiles } from './ResultPreviewTypes';
+
+interface SandpackContentProps {
+  activeView: 'preview' | 'code';
+  filesContent: SandpackFiles;
+  isStreaming: boolean;
+  codeReady: boolean;
+  sandpackKey: string;
+  setActiveView: (view: 'preview' | 'code') => void;
+  setBundlingComplete: (complete: boolean) => void;
+  dependencies: Record<string, string>;
+}
+
+const SandpackContent: React.FC<SandpackContentProps> = ({
+  activeView,
+  filesContent,
+  isStreaming,
+  sandpackKey,
+  codeReady,
+  setActiveView,
+  setBundlingComplete,
+  dependencies,
+}) => {
+  const codeEditorRef = useRef<HTMLDivElement>(null);
+  const [isDarkMode, setIsDarkMode] = useState(false);
+  const previousViewRef = useRef(activeView);
+  const scrollPositionRef = useRef(0);
+
+  useEffect(() => {
+    const prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
+    setIsDarkMode(prefersDarkMode);
+
+    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
+    const handleChange = (e: MediaQueryListEvent) => {
+      setIsDarkMode(e.matches);
+    };
+
+    mediaQuery.addEventListener('change', handleChange);
+    return () => mediaQuery.removeEventListener('change', handleChange);
+  }, []);
+
+  // Handle view changes to preserve scroll position
+  useEffect(() => {
+    if (activeView !== previousViewRef.current) {
+      if (previousViewRef.current === 'code' && codeEditorRef.current) {
+        // Store scroll position when leaving code view
+        const scroller = codeEditorRef.current.querySelector('.cm-scroller');
+        if (scroller instanceof HTMLElement) {
+          scrollPositionRef.current = scroller.scrollTop;
+        }
+      }
+      
+      previousViewRef.current = activeView;
+      
+      if (activeView === 'code') {
+        // Restore scroll position when returning to code view
+        // Use requestAnimationFrame to ensure DOM is ready
+        requestAnimationFrame(() => {
+          if (codeEditorRef.current) {
+            const scroller = codeEditorRef.current.querySelector('.cm-scroller');
+            if (scroller instanceof HTMLElement) {
+              scroller.scrollTop = scrollPositionRef.current;
+            }
+          }
+        });
+      }
+    }
+  }, [activeView]);
+
+  return (
+    <div data-testid="sandpack-provider">
+      <SandpackProvider
+        key={sandpackKey}
+        template="vite-react"
+        options={{
+          externalResources: ['https://cdn.tailwindcss.com'],
+          classes: { 'sp-wrapper': 'h-full' },
+        }}
+        customSetup={{
+          dependencies: {
+            'use-fireproof': '0.20.0-dev-preview-52',
+            ...(dependencies || {}),
+          },
+        }}
+        files={filesContent}
+        theme={isDarkMode ? 'dark' : 'light'}
+      >
+        <SandpackScrollController 
+          isStreaming={isStreaming} 
+          shouldEnableScrolling={isStreaming || !codeReady}
+          codeReady={codeReady}
+          activeView={activeView}
+        />
+        <SandpackLayout className="h-full" style={{ height: 'calc(100vh - 49px)' }}>
+          <div
+            style={{
+              display: activeView === 'preview' ? 'block' : 'none',
+              height: '100%',
+              width: '100%',
+            }}
+          >
+            {!isStreaming && (
+              <SandpackPreview
+                showNavigator={false}
+                showOpenInCodeSandbox={false}
+                showRefreshButton={true}
+                showRestartButton={false}
+                showOpenNewtab={false}
+                className="h-full w-full"
+                style={{ height: '100%' }}
+              />
+            )}
+          </div>
+          <div
+            style={{
+              display: activeView === 'code' ? 'block' : 'none',
+              height: '100%',
+              width: '100%',
+            }}
+            ref={codeEditorRef}
+          >
+            <SandpackCodeEditor
+              style={{ height: '100%' }}
+              showLineNumbers={false}
+              wrapContent
+              showInlineErrors
+            />
+          </div>
+        </SandpackLayout>
+      </SandpackProvider>
+    </div>
+  );
+};
+
+export default SandpackContent;
diff --git a/app/components/ResultPreview/SandpackEventListener.tsx b/app/components/ResultPreview/SandpackEventListener.tsx
deleted file mode 100644
index a5446ac..0000000
--- a/app/components/ResultPreview/SandpackEventListener.tsx
+++ /dev/null
@@ -1,40 +0,0 @@
-import { useEffect } from 'react';
-import { useSandpack } from '@codesandbox/sandpack-react';
-
-interface SandpackEventListenerProps {
-  setActiveView: (view: 'preview' | 'code') => void;
-  setBundlingComplete: (complete: boolean) => void;
-  isStreaming: boolean;
-}
-
-const SandpackEventListener: React.FC<SandpackEventListenerProps> = ({
-  setActiveView,
-  setBundlingComplete,
-  isStreaming,
-}) => {
-  const { listen } = useSandpack();
-
-  useEffect(() => {
-    setBundlingComplete(false);
-
-    const unsubscribe = listen((message) => {
-      if (message.type === 'start') {
-        setBundlingComplete(false);
-      } else if (message.type === 'urlchange') {
-        setBundlingComplete(true);
-
-        if (!isStreaming) {
-          setActiveView('preview');
-        }
-      }
-    });
-
-    return () => {
-      unsubscribe();
-    };
-  }, [listen, setActiveView, setBundlingComplete, isStreaming]);
-
-  return null;
-};
-
-export default SandpackEventListener;
diff --git a/app/components/ResultPreview/SandpackScrollController.tsx b/app/components/ResultPreview/SandpackScrollController.tsx
index 01581fd..9bf8975 100644
--- a/app/components/ResultPreview/SandpackScrollController.tsx
+++ b/app/components/ResultPreview/SandpackScrollController.tsx
@@ -1,121 +1,124 @@
 import { useEffect, useRef } from 'react';
 
+// Create static refs that persist across component remounts
+// These will maintain state even when the component is unmounted and remounted
+const staticRefs = {
+  lastScrollHeight: 0,
+  lastScrollPosition: 0,
+  isScrolling: false,
+  hasUserScrolled: false,
+  highlightInterval: null as NodeJS.Timeout | null,
+  contentObserver: null as MutationObserver | null,
+  checkForScrollerInterval: null as NodeJS.Timeout | null,
+  scroller: null as HTMLElement | null,
+  scrollInProgress: false,
+  renderCount: 0,
+  scrollerSetupComplete: false,
+  lastScrollTime: 0,
+  mountTimestamp: 0,
+  mountDebounceTimeout: null as NodeJS.Timeout | null,
+  isScrollingScheduled: false,
+  lastHighlightTime: 0,
+};
+
 interface SandpackScrollControllerProps {
   isStreaming: boolean;
+  shouldEnableScrolling?: boolean;
+  codeReady?: boolean;
+  activeView?: 'preview' | 'code';
 }
 
-const SandpackScrollController: React.FC<SandpackScrollControllerProps> = ({ isStreaming }) => {
-  const lastScrollHeight = useRef(0);
-  const lastScrollPosition = useRef(0);
-  const isScrolling = useRef(false);
-  const hasUserScrolled = useRef(false);
-  const highlightIntervalRef = useRef<NodeJS.Timeout | null>(null);
+// Debug logging function to track scroll issues
+const debugLog = (message: string, data?: any) => {
+  console.log(`[ScrollDebug] ${message}`, data || '');
+};
 
+const SandpackScrollController: React.FC<SandpackScrollControllerProps> = ({ 
+  isStreaming,
+  shouldEnableScrolling = isStreaming, // Default to isStreaming if not provided
+  codeReady = false,
+  activeView = 'preview' // Default to preview view
+}) => {
+  // We still keep component-level refs for React's hook rules,
+  // but they're just pointers to our static refs
+  const componentMounted = useRef(false);
+  const cleanupCalled = useRef(false);
+  // Local refs to hold the props
+  const propsRef = useRef({ isStreaming, codeReady, activeView });
+
+  // Update props ref when they change
   useEffect(() => {
-    let primaryScroller: HTMLElement | null = null;
-
-    if (!document.getElementById('highlight-style')) {
-      const style = document.createElement('style');
-      style.id = 'highlight-style';
-      style.textContent = `
-        .cm-line-highlighted {
-          position: relative !important;
-          border-left: 3px solid rgba(0, 137, 249, 0.27) !important;
-          color: inherit !important;
-        }
-        
-        .cm-line-highlighted::before {
-          content: "" !important;
-          position: absolute !important;
-          top: 0 !important;
-          left: 0 !important;
-          right: 0 !important;
-          bottom: 0 !important;
-          background: linear-gradient(60deg, rgba(0, 128, 255, 0.15), rgba(224, 255, 255, 0.25), rgba(0, 183, 255, 0.15)) !important;
-          background-size: 200% 200% !important;
-          animation: sparkleAppear 2s ease-out !important;
-          pointer-events: none !important;
-          z-index: -1 !important;
-        }
-        
-        @keyframes sparkleGradient {
-          0% { background-position: 0% 50% }
-          50% { background-position: 100% 50% }
-          100% { background-position: 0% 50% }
-        }
+    propsRef.current = { isStreaming, codeReady, activeView };
+  }, [isStreaming, codeReady, activeView]);
+
+  // Simple check if we should be scrolling
+  const shouldScroll = () => {
+    // Use the values from propsRef to ensure we're using the latest props
+    const { isStreaming, codeReady, activeView } = propsRef.current;
+    return isStreaming && !codeReady && activeView === 'code';
+  };
+
+  // Setup the scroller observer only once it's found - with debounce
+  const setupScrollerOnce = () => {
+    if (staticRefs.scrollerSetupComplete || !staticRefs.scroller) return;
+    
+    debugLog(`Setting up scroller for the first time`, { height: staticRefs.scroller.scrollHeight });
+    
+    // Setup scroll listener with throttling
+    const handleScroll = () => {
+      if (staticRefs.isScrolling || !staticRefs.scroller) return;
+
+      const now = Date.now();
+      if (now - staticRefs.lastScrollTime < 50) return; // Throttle to max 20 events per second
+      staticRefs.lastScrollTime = now;
+
+      const currentPosition = staticRefs.scroller.scrollTop;
+      const delta = Math.abs(currentPosition - staticRefs.lastScrollPosition);
+      
+      if (delta > 10) {
+        const wasUserScrolled = staticRefs.hasUserScrolled;
+        staticRefs.hasUserScrolled = true;
+        staticRefs.lastScrollPosition = currentPosition;
         
-        @keyframes sparkleAppear {
-          0% { opacity: 0.8; }
-          50% { opacity: 0.8; }
-          100% { opacity: 0.1; }
-        }
-      `;
-      document.head.appendChild(style);
-    }
-
-    const scrollToBottom = () => {
-      if (!primaryScroller) return;
-      isScrolling.current = true;
-
-      requestAnimationFrame(() => {
-        if (primaryScroller) {
-          primaryScroller.scrollTop = primaryScroller.scrollHeight;
-          lastScrollHeight.current = primaryScroller.scrollHeight;
-          lastScrollPosition.current = primaryScroller.scrollTop;
+        if (wasUserScrolled !== true) {
+          debugLog(`User scroll state changed to true`);
         }
-        isScrolling.current = false;
-      });
-    };
-
-    const highlightLastLine = () => {
-      if (!primaryScroller || !isStreaming) return;
-
-      document.querySelectorAll('.cm-line-highlighted').forEach((el) => {
-        el.classList.remove('cm-line-highlighted');
-      });
-
-      const lines = Array.from(document.querySelectorAll('.cm-line'));
-      let lastLine = null;
 
-      for (let i = lines.length - 1; i >= 0; i--) {
-        const line = lines[i];
-        const content = line.textContent || '';
-        if (content.trim() && !content.includes('END OF CODE')) {
-          lastLine = line;
-          break;
+        // Check if scrolled to bottom
+        const atBottom = 
+          staticRefs.scroller.scrollTop + staticRefs.scroller.clientHeight >=
+          staticRefs.scroller.scrollHeight - 50;
+        
+        if (atBottom) {
+          staticRefs.hasUserScrolled = false;
+          debugLog(`User scrolled to bottom, resetting hasUserScrolled`);
         }
       }
-
-      if (lastLine) {
-        lastLine.classList.add('cm-line-highlighted');
-      }
     };
 
-    const checkForScroller = setInterval(() => {
-      if (primaryScroller) {
-        clearInterval(checkForScroller);
-        return;
-      }
-
-      const newScroller = document.querySelector('.cm-scroller');
-      if (newScroller && newScroller instanceof HTMLElement) {
-        primaryScroller = newScroller;
-
-        scrollToBottom();
-
-        setupContentObserver();
-      }
-    }, 100);
-
-    const setupContentObserver = () => {
-      if (!primaryScroller) return;
-
-      const contentObserver = new MutationObserver(() => {
-        if (!primaryScroller) return;
-
-        const newHeight = primaryScroller.scrollHeight;
+    // Setup content observer with more efficient mutation handling
+    if (staticRefs.contentObserver) {
+      staticRefs.contentObserver.disconnect();
+    }
 
-        if (isStreaming) {
+    const contentObserver = new MutationObserver((mutations) => {
+      if (!staticRefs.scroller) return;
+      
+      // Coalesce multiple mutations that happen close together
+      if (staticRefs.isScrollingScheduled) return;
+      staticRefs.isScrollingScheduled = true;
+      
+      // Debounce the scroll operation to handle rapid mutations
+      setTimeout(() => {
+        staticRefs.isScrollingScheduled = false;
+        
+        if (!staticRefs.scroller) return;
+        
+        const oldHeight = staticRefs.lastScrollHeight;
+        const newHeight = staticRefs.scroller.scrollHeight;
+        
+        // Check if conditions still valid
+        if (shouldScroll()) {
           highlightLastLine();
         } else {
           document.querySelectorAll('.cm-line-highlighted').forEach((el) => {
@@ -123,85 +126,274 @@ const SandpackScrollController: React.FC<SandpackScrollControllerProps> = ({ isS
           });
         }
 
-        if (newHeight === lastScrollHeight.current) return;
-
-        const isNearBottom =
-          primaryScroller.scrollTop + primaryScroller.clientHeight > lastScrollHeight.current - 100;
-
-        if (!hasUserScrolled.current || isNearBottom) {
+        // Always try to scroll when height changes during streaming
+        if (newHeight !== oldHeight && shouldScroll()) {
           scrollToBottom();
+          staticRefs.lastScrollHeight = newHeight;
+          return;
         }
 
-        lastScrollHeight.current = newHeight;
-      });
-
-      const handleScroll = () => {
-        if (isScrolling.current || !primaryScroller) return;
+        // Only check isNearBottom if height has changed
+        if (newHeight === oldHeight) {
+          return;
+        }
 
-        const currentPosition = primaryScroller.scrollTop;
-        if (Math.abs(currentPosition - lastScrollPosition.current) > 10) {
-          hasUserScrolled.current = true;
-          lastScrollPosition.current = currentPosition;
+        const isNearBottom =
+          staticRefs.scroller.scrollTop + staticRefs.scroller.clientHeight > oldHeight - 100;
 
-          if (
-            primaryScroller.scrollTop + primaryScroller.clientHeight >=
-            primaryScroller.scrollHeight - 50
-          ) {
-            hasUserScrolled.current = false;
-          }
+        if (!staticRefs.hasUserScrolled || isNearBottom) {
+          scrollToBottom();
         }
-      };
-
-      if (primaryScroller) {
-        contentObserver.observe(primaryScroller, {
-          childList: true,
-          subtree: true,
-          characterData: true,
-        });
 
-        primaryScroller.addEventListener('scroll', handleScroll);
+        staticRefs.lastScrollHeight = newHeight;
+      }, 10); // Small delay to coalesce rapid mutations
+    });
+
+    contentObserver.observe(staticRefs.scroller, {
+      childList: true,
+      subtree: true,
+      characterData: true,
+    });
+    
+    staticRefs.scroller.addEventListener('scroll', handleScroll);
+    staticRefs.contentObserver = contentObserver;
+    staticRefs.scrollerSetupComplete = true;
+    
+    debugLog(`Scroller setup complete`, { height: staticRefs.scroller.scrollHeight });
+    
+    // Do initial scroll and highlight
+    if (shouldScroll()) {
+      highlightLastLine();
+      scrollToBottom();
+    }
+  };
+
+  // Scroll to bottom function - simplified and more robust with debounce
+  const scrollToBottom = () => {
+    if (!staticRefs.scroller) return;
+    
+    if (staticRefs.scrollInProgress) {
+      return;
+    }
+    
+    const now = Date.now();
+    if (now - staticRefs.lastScrollTime < 50) return; // Don't scroll too frequently
+    staticRefs.lastScrollTime = now;
+    
+    staticRefs.isScrolling = true;
+    staticRefs.scrollInProgress = true;
+
+    // Ensure scrolling happens reliably with multiple animation frames
+    let scrollAttempts = 0;
+    const ensureScrolled = () => {
+      if (!staticRefs.scroller || scrollAttempts >= 3) {
+        staticRefs.isScrolling = false;
+        staticRefs.scrollInProgress = false;
+        return;
+      }
+      
+      scrollAttempts++;
+      staticRefs.scroller.scrollTop = staticRefs.scroller.scrollHeight;
+      
+      // Check if we need another attempt
+      if (staticRefs.scroller.scrollTop < staticRefs.scroller.scrollHeight - 10) {
+        requestAnimationFrame(ensureScrolled);
+      } else {
+        staticRefs.lastScrollHeight = staticRefs.scroller.scrollHeight;
+        staticRefs.lastScrollPosition = staticRefs.scroller.scrollTop;
+        staticRefs.isScrolling = false;
+        staticRefs.scrollInProgress = false;
+      }
+    };
+    
+    requestAnimationFrame(ensureScrolled);
+  };
+
+  // Highlight last line function with debounce
+  const highlightLastLine = () => {
+    if (!staticRefs.scroller || !shouldScroll()) return;
+    
+    const now = Date.now();
+    if (now - staticRefs.lastHighlightTime < 100) return; // Limit highlighting frequency
+    staticRefs.lastHighlightTime = now;
+
+    document.querySelectorAll('.cm-line-highlighted').forEach((el) => {
+      el.classList.remove('cm-line-highlighted');
+    });
+
+    const lines = Array.from(document.querySelectorAll('.cm-line'));
+    let lastLine = null;
+
+    for (let i = lines.length - 1; i >= 0; i--) {
+      const line = lines[i];
+      const content = line.textContent || '';
+      if (content.trim() && !content.includes('END OF CODE')) {
+        lastLine = line;
+        break;
+      }
+    }
 
-        if (isStreaming) {
-          highlightLastLine();
+    if (lastLine) {
+      lastLine.classList.add('cm-line-highlighted');
+      
+      // Only scroll into view if we're in streaming mode
+      if (shouldScroll()) {
+        // Use a more reliable way to scroll to the element
+        const rect = lastLine.getBoundingClientRect();
+        if (rect && staticRefs.scroller) {
+          const scrollerRect = staticRefs.scroller.getBoundingClientRect();
+          if (rect.bottom > scrollerRect.bottom) {
+            staticRefs.scroller.scrollTop = staticRefs.scroller.scrollHeight;
+          }
         }
       }
+    }
+  };
 
-      if (isStreaming) {
-        highlightIntervalRef.current = setInterval(highlightLastLine, 10);
+  // Main effect to handle mounting and cleanup - debounced to prevent rapid remounting issues
+  useEffect(() => {
+    // Record mount timestamp
+    const thisRenderTime = Date.now();
+    
+    // Clear any existing debounce timeout
+    if (staticRefs.mountDebounceTimeout) {
+      clearTimeout(staticRefs.mountDebounceTimeout);
+    }
+    
+    // Debounce the mount setup to prevent thrashing on frequent remounts
+    staticRefs.mountDebounceTimeout = setTimeout(() => {
+      // Only proceed if this is still the latest mount
+      if (thisRenderTime !== staticRefs.mountTimestamp) return;
+      
+      staticRefs.renderCount++;
+      cleanupCalled.current = false;
+      componentMounted.current = true;
+      
+      debugLog(`Component mounted, render count: ${staticRefs.renderCount}`);
+      
+      // Add the highlight styles if they don't exist
+      if (!document.getElementById('highlight-style')) {
+        const style = document.createElement('style');
+        style.id = 'highlight-style';
+        style.textContent = `
+          .cm-line-highlighted {
+            position: relative !important;
+            border-left: 3px solid rgba(0, 137, 249, 0.6) !important;
+            color: inherit !important;
+          }
+          
+          .cm-line-highlighted::before {
+            content: "" !important;
+            position: absolute !important;
+            top: 0 !important;
+            left: 0 !important;
+            right: 0 !important;
+            bottom: 0 !important;
+            background: linear-gradient(
+              90deg, 
+              rgba(0, 128, 255, 0.12) 0%, 
+              rgba(224, 255, 255, 0.2) 50%, 
+              rgba(0, 183, 255, 0.12) 100%
+            ) !important;
+            background-size: 200% 100% !important;
+            animation: sparkleFlow 1.8s ease-in-out infinite !important;
+            pointer-events: none !important;
+            z-index: -1 !important;
+          }
+          
+          @keyframes sparkleFlow {
+            0% { background-position: 0% 50%; opacity: 0.7; }
+            50% { background-position: 100% 50%; opacity: 0.85; }
+            100% { background-position: 0% 50%; opacity: 0.7; }
+          }
+        `;
+        document.head.appendChild(style);
       }
 
-      return () => {
-        clearInterval(checkForScroller);
-        if (highlightIntervalRef.current) {
-          clearInterval(highlightIntervalRef.current);
-          highlightIntervalRef.current = null;
-        }
-        contentObserver.disconnect();
-        primaryScroller?.removeEventListener('scroll', handleScroll);
-      };
-    };
+      // If we already have a scroller, use it
+      if (staticRefs.scroller) {
+        setupScrollerOnce();
+      }
+      
+      // Otherwise, check for it periodically
+      if (!staticRefs.checkForScrollerInterval) {
+        staticRefs.checkForScrollerInterval = setInterval(() => {
+          if (staticRefs.scroller) return;
+          
+          const newScroller = document.querySelector('.cm-scroller');
+          if (newScroller && newScroller instanceof HTMLElement) {
+            staticRefs.scroller = newScroller;
+            setupScrollerOnce();
+          }
+        }, 100);
+      }
 
-    setTimeout(scrollToBottom, 100);
+      // Update highlight interval based on current conditions
+      updateHighlightInterval();
+    }, 150); // Debounce period - only set up if component stays mounted for 150ms
+    
+    // Record this mount as the latest
+    staticRefs.mountTimestamp = thisRenderTime;
 
+    // Cleanup function
     return () => {
-      clearInterval(checkForScroller);
-      if (highlightIntervalRef.current) {
-        clearInterval(highlightIntervalRef.current);
-        highlightIntervalRef.current = null;
+      debugLog(`Component cleanup triggered, render count: ${staticRefs.renderCount}`);
+      
+      // Don't do expensive cleanup on rapid remounts
+      if (Date.now() - thisRenderTime < 100) {
+        debugLog(`Skipping cleanup due to short mount duration`);
+        return;
       }
+      
+      // Mark component as unmounted
+      cleanupCalled.current = true;
+      componentMounted.current = false;
     };
-  }, [isStreaming]);
-
-  useEffect(() => {
-    if (!isStreaming && highlightIntervalRef.current) {
-      clearInterval(highlightIntervalRef.current);
-      highlightIntervalRef.current = null;
-
+  }, []); // Empty dependency array - we manage state independently
+
+  // Function to update the highlight interval
+  const updateHighlightInterval = () => {
+    const shouldBeScrolling = shouldScroll();
+    
+    if (shouldBeScrolling) {
+      if (!staticRefs.highlightInterval) {
+        staticRefs.highlightInterval = setInterval(() => {
+          // Check again inside interval in case conditions changed
+          if (shouldScroll() && staticRefs.scroller) {
+            highlightLastLine();
+            scrollToBottom();
+          }
+        }, 200); // Less frequent interval to reduce CPU usage
+      }
+    } else if (staticRefs.highlightInterval) {
+      clearInterval(staticRefs.highlightInterval);
+      staticRefs.highlightInterval = null;
+      
+      // Clear highlights when not in streaming mode
       document.querySelectorAll('.cm-line-highlighted').forEach((el) => {
         el.classList.remove('cm-line-highlighted');
       });
     }
-  }, [isStreaming]);
+  };
+
+  // Effect for responding to condition changes - with debounce
+  useEffect(() => {
+    debugLog(`Conditions updated: isStreaming=${isStreaming}, codeReady=${codeReady}, activeView=${activeView}, shouldScroll=${shouldScroll()}`);
+    
+    // Don't immediately react to prop changes - debounce them
+    const timeoutId = setTimeout(() => {
+      // Update interval based on conditions
+      updateHighlightInterval();
+      
+      // Perform immediate scroll and highlight if needed
+      if (shouldScroll() && staticRefs.scroller) {
+        highlightLastLine();
+        scrollToBottom();
+      }
+    }, 100); // Small debounce to prevent rapid changes from causing issues
+    
+    return () => clearTimeout(timeoutId);
+  }, [isStreaming, codeReady, activeView]);
 
   return null;
 };
diff --git a/app/components/ResultPreview/WelcomeScreen.tsx b/app/components/ResultPreview/WelcomeScreen.tsx
index e63f911..7498c2c 100644
--- a/app/components/ResultPreview/WelcomeScreen.tsx
+++ b/app/components/ResultPreview/WelcomeScreen.tsx
@@ -3,7 +3,7 @@ import React from 'react';
 const WelcomeScreen = () => {
   return (
     <div className="bg-light-background-00 dark:bg-dark-background-00 flex h-full flex-col items-center justify-center">
-      <img src="/lightup.png" alt="Lightup" className="logo-pulse h-auto w-full max-w-xs" />
+      <img src="/lightup.png" alt="Lightup" className="logo-pulse h-auto w-full max-w-xs opacity-10" />
     </div>
   );
 };
diff --git a/app/components/SessionSidebar.tsx b/app/components/SessionSidebar.tsx
index f5a2df4..fd8ce6d 100644
--- a/app/components/SessionSidebar.tsx
+++ b/app/components/SessionSidebar.tsx
@@ -1,129 +1,17 @@
-import { useEffect, useRef, memo, useMemo, useState } from 'react';
-import { useFireproof } from 'use-fireproof';
-import { Link } from 'react-router';
-
-function ImgFile({
-  file,
-  alt,
-  className,
-}: {
-  file: { file: () => Promise<File>; type: string };
-  alt: string;
-  className: string;
-}) {
-  const [imgDataUrl, setImgDataUrl] = useState('');
-  useEffect(() => {
-    if (file.type && /image/.test(file.type)) {
-      file.file().then((file: File) => {
-        const src = URL.createObjectURL(file);
-        setImgDataUrl(src);
-        return () => URL.revokeObjectURL(src);
-      });
-    }
-  }, [file]);
-  return imgDataUrl ? (
-    <img className={`${className} max-h-60 max-w-full object-contain`} alt={alt} src={imgDataUrl} />
-  ) : null;
-}
-
-// Add these type definitions at the top of the file
-interface DocBase {
-  _id: string;
-}
-
-interface ScreenshotDocument extends DocBase {
-  type: 'screenshot';
-  session_id: string;
-  _files?: {
-    screenshot: { file: () => Promise<File>; type: string };
-  };
-}
-
-// Modify SessionDocument to include optional type
-interface SessionDocument extends DocBase {
-  type?: 'session'; // Make it optional since existing docs might not have it
-  title?: string;
-  timestamp: number;
-  messages?: Array<{
-    text: string;
-    type: 'user' | 'ai';
-    code?: string;
-    dependencies?: Record<string, string>;
-  }>;
-}
-
-// Union type for documents returned by query
-type SessionOrScreenshot = SessionDocument | ScreenshotDocument;
-
-// Helper function to encode titles for URLs
-function encodeTitle(title: string): string {
-  return encodeURIComponent(title || 'untitled-session')
-    .toLowerCase()
-    .replace(/%20/g, '-');
-}
-
-interface SessionSidebarProps {
-  isVisible: boolean;
-  onClose: () => void;
-  onSelectSession: (session: SessionDocument) => void;
-}
+import { useEffect, useRef, memo, useMemo } from 'react';
+import { useSessionList } from '../hooks/sidebar/useSessionList';
+import { ImgFile } from './SessionSidebar/ImgFile';
+import { encodeTitle } from './SessionSidebar/utils';
+import type { SessionSidebarProps, SessionOrScreenshot, SessionDocument } from '../types/chat';
 
 /**
  * Component that displays a collapsible sidebar with chat session history
  */
-function SessionSidebar({ isVisible, onClose, onSelectSession }: SessionSidebarProps) {
-  const { database, useLiveQuery } = useFireproof('fireproof-chat-history');
+function SessionSidebar({ isVisible, onClose }: SessionSidebarProps) {
   const sidebarRef = useRef<HTMLDivElement>(null);
 
-  // // Query chat sessions ordered by timestamp (newest first)
-  // const { docs: sessions } = useLiveQuery('type', {
-  //   key: 'session',
-  //   descending: true,
-  // });
-
-  // // Query chat sessions ordered by timestamp (newest first)
-  // const { docs: screenshots } = useLiveQuery('type', {
-  //   key: 'screenshot',
-  //   descending: true,
-  // });
-
-  const { docs: sessionAndScreenshots } = useLiveQuery<SessionOrScreenshot>((doc) =>
-    doc.type && doc.type === 'screenshot' ? doc.session_id : doc._id
-  );
-
-  // Group sessions and screenshots together
-  const groupedSessions = useMemo(() => {
-    const groups = new Map<
-      string,
-      { session?: SessionDocument; screenshots: ScreenshotDocument[] }
-    >();
-
-    sessionAndScreenshots.forEach((doc) => {
-      if ('type' in doc && doc.type === 'screenshot') {
-        // Handle screenshot
-        const sessionId = doc.session_id;
-        let group = groups.get(sessionId);
-        if (!group) {
-          group = { session: undefined, screenshots: [] };
-          groups.set(sessionId, group);
-        }
-        group.screenshots.push(doc as ScreenshotDocument);
-      } else {
-        // Handle session
-        let group = groups.get(doc._id);
-        if (!group) {
-          group = { session: undefined, screenshots: [] };
-          groups.set(doc._id, group);
-        }
-        group.session = doc as SessionDocument;
-      }
-    });
-
-    // Convert map to array and sort by session timestamp
-    return Array.from(groups.values())
-      .filter((group) => group.session) // Only include groups with sessions
-      .sort((a, b) => (b.session!.timestamp || 0) - (a.session!.timestamp || 0));
-  }, [sessionAndScreenshots]) as { session: SessionDocument; screenshots: ScreenshotDocument[] }[];
+  // Use the custom hook instead of direct database queries
+  const { groupedSessions } = useSessionList();
 
   // Handle clicks outside the sidebar to close it
   useEffect(() => {
@@ -144,16 +32,6 @@ function SessionSidebar({ isVisible, onClose, onSelectSession }: SessionSidebarP
     };
   }, [isVisible, onClose]);
 
-  // Select a session and notify parent component
-  const handleSelectSession = (session: SessionDocument) => {
-    // Call the provided onSelectSession handler
-    onSelectSession(session);
-    // Close the sidebar on mobile
-    if (window.innerWidth < 768) {
-      onClose();
-    }
-  };
-
   // Memoize the sidebar classes to prevent recalculations on every render
   const sidebarClasses = useMemo(() => {
     return `bg-light-background-00 dark:bg-dark-background-00 fixed top-0 left-0 z-10 h-full shadow-lg transition-all duration-300 ${
@@ -163,53 +41,49 @@ function SessionSidebar({ isVisible, onClose, onSelectSession }: SessionSidebarP
 
   // Render session items with Link components
   const renderSessionItems = () => {
-    return groupedSessions
-      .map(({ session, screenshots }) => {
-        // Skip if this isn't a session document
-        if (!session || !('_id' in session)) {
-          return null;
-        }
-
-        // Cast to SessionDocument to access title
-        const sessionDoc = session as SessionDocument;
-        const title = sessionDoc.title || 'New Chat';
-        const encodedTitle = encodeTitle(title);
+    return groupedSessions.map(({ session, screenshots }) => {
+      // Skip if this isn't a session document
+      if (!session || !('_id' in session)) {
+        return null;
+      }
 
-        return (
-          <li
-            key={sessionDoc._id}
-            className="cursor-pointer border-b border-gray-200 p-3 hover:bg-gray-100 dark:border-gray-700 dark:hover:bg-gray-800"
-            data-testid="session-item"
+      const title = session.title || 'New Chat';
+      const encodedTitle = encodeTitle(title);
+
+      // first and last screenshots, if they exist, and unique
+      const shownScreenshots = [screenshots[0], screenshots[screenshots.length - 1]]
+        .filter((screenshot) => screenshot !== undefined)
+        .filter((screenshot, index, self) => self.findIndex((t) => t._id === screenshot._id) === index);
+
+      return (
+        <li
+          key={session._id}
+          className="cursor-pointer border-b border-gray-200 p-3 hover:bg-gray-100 dark:border-gray-700 dark:hover:bg-gray-800"
+        >
+          <a
+            href={`/chat/${session._id}/${encodedTitle}`}
+            className="block"
+            onClick={() => onClose()}
           >
-            <Link
-              to={`/session/${sessionDoc._id}/${encodedTitle}`}
-              className="block"
-              onClick={(e) => {
-                // Don't navigate, just use the handler
-                e.preventDefault();
-                handleSelectSession(sessionDoc);
-              }}
-            >
-              <div className="text-sm font-semibold text-gray-900 dark:text-white">{title}</div>
-              <div className="mt-1 text-xs text-gray-500 dark:text-gray-400">
-                {new Date(sessionDoc.timestamp).toLocaleString()}
-              </div>
-              {screenshots.map(
-                (screenshot) =>
-                  screenshot._files?.screenshot && (
-                    <ImgFile
-                      key={screenshot._id}
-                      file={screenshot._files.screenshot}
-                      alt={`Screenshot from ${title}`}
-                      className="mt-2"
-                    />
-                  )
-              )}
-            </Link>
-          </li>
-        );
-      })
-      .filter(Boolean);
+            <div className="text-sm font-semibold text-gray-900 dark:text-white">{title}</div>
+            <div className="mt-1 text-xs text-gray-500 dark:text-gray-400">
+              {new Date(session.created_at).toLocaleString()}
+            </div>
+            {shownScreenshots.map(
+              (screenshot) =>
+                screenshot._files?.screenshot && (
+                  <ImgFile
+                    key={screenshot._id}
+                    file={screenshot._files.screenshot}
+                    alt={`Screenshot from ${title}`}
+                    className="mt-2"
+                  />
+                )
+            )}
+          </a>
+        </li>
+      );
+    });
   };
 
   // Conditionally render content but keep animation classes
@@ -267,9 +141,5 @@ function SessionSidebar({ isVisible, onClose, onSelectSession }: SessionSidebarP
 export default memo(SessionSidebar, (prevProps, nextProps) => {
   // Only re-render if isVisible changes
   // Note: Functions should be memoized by parent components
-  return (
-    prevProps.isVisible === nextProps.isVisible &&
-    prevProps.onClose === nextProps.onClose &&
-    prevProps.onSelectSession === nextProps.onSelectSession
-  );
+  return prevProps.isVisible === nextProps.isVisible && prevProps.onClose === nextProps.onClose;
 });
diff --git a/app/components/SessionSidebar/ImgFile.tsx b/app/components/SessionSidebar/ImgFile.tsx
new file mode 100644
index 0000000..6315ee3
--- /dev/null
+++ b/app/components/SessionSidebar/ImgFile.tsx
@@ -0,0 +1,29 @@
+import { useEffect, useState } from 'react';
+
+interface ImgFileProps {
+  file: { file: () => Promise<File>; type: string };
+  alt: string;
+  className: string;
+}
+
+/**
+ * Component to display an image file from a Fireproof file attachment
+ * It handles loading the file and converting it to a data URL
+ */
+export function ImgFile({ file, alt, className }: ImgFileProps) {
+  const [imgDataUrl, setImgDataUrl] = useState('');
+
+  useEffect(() => {
+    if (file.type && /image/.test(file.type)) {
+      file.file().then((file: File) => {
+        const src = URL.createObjectURL(file);
+        setImgDataUrl(src);
+        return () => URL.revokeObjectURL(src);
+      });
+    }
+  }, [file]);
+
+  return imgDataUrl ? (
+    <img className={`${className} max-h-60 max-w-full object-contain`} alt={alt} src={imgDataUrl} />
+  ) : null;
+}
diff --git a/app/components/SessionSidebar/utils.ts b/app/components/SessionSidebar/utils.ts
new file mode 100644
index 0000000..41064cd
--- /dev/null
+++ b/app/components/SessionSidebar/utils.ts
@@ -0,0 +1,12 @@
+/**
+ * Helper function to encode titles for URLs
+ * Converts spaces to hyphens and encodes special characters
+ *
+ * @param title - The title string to encode
+ * @returns Encoded URL-friendly string
+ */
+export function encodeTitle(title: string): string {
+  return encodeURIComponent(title || 'untitled-chat')
+    .toLowerCase()
+    .replace(/%20/g, '-');
+}
diff --git a/app/components/StructuredMessage.tsx b/app/components/StructuredMessage.tsx
new file mode 100644
index 0000000..41cdc49
--- /dev/null
+++ b/app/components/StructuredMessage.tsx
@@ -0,0 +1,103 @@
+import { memo } from 'react';
+import ReactMarkdown from 'react-markdown';
+import type { Segment } from '../types/chat';
+
+interface StructuredMessageProps {
+  segments: Segment[];
+  isStreaming?: boolean;
+}
+
+/**
+ * Component for displaying structured messages with markdown and code segments
+ */
+const StructuredMessage = memo(({ segments, isStreaming }: StructuredMessageProps) => {
+  // Ensure segments is an array (defensive)
+  const validSegments = Array.isArray(segments) ? segments : [];
+
+  // Count number of lines in code segments
+  const codeLines = validSegments
+    .filter((segment) => segment.type === 'code')
+    .reduce((acc, segment) => acc + (segment.content?.split('\n').length || 0), 0);
+
+  // CRITICAL: We always want to show something if there's any content at all
+  const hasContent =
+    validSegments.length > 0 &&
+    validSegments.some((segment) => segment?.content && segment.content.trim().length > 0);
+
+  return (
+    <div className="structured-message">
+      {!hasContent ? (
+        // Show placeholder if there are no segments with content
+        <div className="prose prose-sm dark:prose-invert max-w-none prose-ul:pl-5 prose-ul:list-disc prose-ol:pl-5 prose-ol:list-decimal prose-li:my-0">
+          <p>Processing response...</p>
+        </div>
+      ) : (
+        // Map and render each segment that has content
+        validSegments
+          .filter((segment) => segment?.content && segment.content.trim().length > 0)
+          .map((segment, index) => {
+            if (segment.type === 'markdown') {
+              return (
+                <div
+                  key={`markdown-${index}`}
+                  className="ai-markdown prose"
+                >
+                  <ReactMarkdown>{segment.content || ''}</ReactMarkdown>
+                </div>
+              );
+            } else if (segment.type === 'code') {
+              // For code segments, show a summary with line count rather than full code
+              const content = segment.content || '';
+              return (
+                <div
+                  key={`code-${index}`}
+                  className="my-4 rounded-lg border border-gray-200 bg-gray-50 p-4 shadow-sm dark:border-gray-700 dark:bg-gray-800"
+                >
+                  <div className="mb-2 flex items-center justify-between">
+                    <span className="font-mono text-sm text-gray-500 dark:text-gray-400">
+                      {`${codeLines} line${codeLines !== 1 ? 's' : ''} of code`}
+                    </span>
+
+                    <button
+                      onClick={() => {
+                        navigator.clipboard.writeText(content);
+                      }}
+                      className="rounded bg-gray-200 px-2 py-1 text-xs transition-colors hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600"
+                    >
+                      <code className="mr-3 font-mono text-gray-400 dark:text-gray-600">
+                        App.jsx
+                      </code>
+                      Copy
+                    </button>
+                  </div>
+
+                  {/* Preview of first few lines */}
+                  <div className="max-h-24 overflow-hidden rounded bg-gray-200 p-2 font-mono text-sm shadow-inner dark:bg-gray-900">
+                    {content
+                      .split('\n')
+                      .slice(0, 3)
+                      .map((line, i) => (
+                        <div key={i} className="truncate">
+                          {line || ' '}
+                        </div>
+                      ))}
+                    {content.split('\n').length > 3 && (
+                      <div className="text-gray-500 dark:text-gray-400">...</div>
+                    )}
+                  </div>
+                </div>
+              );
+            }
+            return null;
+          })
+      )}
+
+      {/* Show streaming indicator only when streaming AND we already have content */}
+      {isStreaming && hasContent && (
+        <span className="bg-light-primary dark:bg-dark-primary ml-1 inline-block h-4 w-2 animate-pulse" />
+      )}
+    </div>
+  );
+});
+
+export default StructuredMessage;
diff --git a/app/config/env.ts b/app/config/env.ts
new file mode 100644
index 0000000..51888f7
--- /dev/null
+++ b/app/config/env.ts
@@ -0,0 +1,11 @@
+/**
+ * Central configuration file for environment variables
+ * Provides fallback values for required environment variables
+ */
+
+// Fireproof database name
+export const FIREPROOF_CHAT_HISTORY =
+  import.meta.env.VITE_FIREPROOF_CHAT_HISTORY || 'fireproof-chat-history';
+
+// Other environment variables can be added here as needed
+export const OPENROUTER_API_KEY = import.meta.env.VITE_OPENROUTER_API_KEY;
diff --git a/app/context/ChatContext.tsx b/app/context/ChatContext.tsx
deleted file mode 100644
index e7a7254..0000000
--- a/app/context/ChatContext.tsx
+++ /dev/null
@@ -1,134 +0,0 @@
-import { createContext, useContext, useState, useCallback, type ReactNode } from 'react';
-import React from 'react';
-
-// Define the core chat state and functionality
-interface ChatContextState {
-  // Core text state
-  input: string;
-  setInput: (input: string) => void;
-
-  // Generation status
-  isGenerating: boolean;
-  setIsGenerating: (isGenerating: boolean) => void;
-
-  // UI state
-  isSidebarVisible: boolean;
-  openSidebar: () => void;
-  closeSidebar: () => void;
-
-  // Core functions
-  handleSendMessage: () => void;
-  handleNewChat: () => void;
-
-  // Input reference and textarea auto-resize
-  inputRef: React.RefObject<HTMLTextAreaElement | null>;
-  autoResizeTextarea: () => void;
-}
-
-// Create the context with undefined default
-const ChatContext = createContext<ChatContextState | undefined>(undefined);
-
-interface ChatProviderProps {
-  children: ReactNode;
-  initialState?: {
-    input?: string;
-    isGenerating?: boolean;
-    isSidebarVisible?: boolean;
-  };
-  // These optional props allow parent components to override behavior
-  onSendMessage?: (input: string) => void;
-  onNewChat?: () => void;
-}
-
-// Provider component
-export function ChatProvider({
-  children,
-  initialState = {},
-  onSendMessage = () => {},
-  onNewChat = () => {},
-}: ChatProviderProps) {
-  // Core state with optional initial values
-  const [input, setInput] = useState(initialState.input || '');
-  const [isGenerating, setIsGenerating] = useState(initialState.isGenerating || false);
-  const [isSidebarVisible, setIsSidebarVisible] = useState(initialState.isSidebarVisible || false);
-
-  // Wrap setInput with debugging
-  const setInputWithDebug = useCallback(
-    (newInput: string) => {
-      setInput(newInput);
-    },
-    [input]
-  );
-
-  // Create input reference
-  const inputRef = React.useRef<HTMLTextAreaElement | null>(null);
-
-  // Auto-resize textarea function
-  const autoResizeTextarea = useCallback(() => {
-    const textarea = inputRef.current;
-    if (textarea) {
-      textarea.style.height = 'auto';
-      textarea.style.height = `${Math.max(60, textarea.scrollHeight)}px`;
-    }
-  }, []);
-
-  // Sidebar visibility functions
-  const openSidebar = useCallback(() => {
-    setIsSidebarVisible(true);
-  }, []);
-
-  const closeSidebar = useCallback(() => {
-    setIsSidebarVisible(false);
-  }, []);
-
-  // Start a new chat
-  const handleNewChat = useCallback(() => {
-    setInput('');
-    setIsGenerating(false);
-
-    // Call the external handler (guaranteed to exist with default)
-    onNewChat();
-  }, [onNewChat]);
-
-  // Send message handler
-  const handleSendMessage = useCallback(() => {
-    if (!input.trim() || isGenerating) return;
-
-    // Set generating state
-    setIsGenerating(true);
-
-    // Call external handler (guaranteed to exist with default)
-    onSendMessage(input);
-
-    // Clear input
-    setInput('');
-  }, [input, isGenerating, onSendMessage]);
-
-  // Context value
-  const contextValue: ChatContextState = {
-    input,
-    setInput: setInputWithDebug,
-    isGenerating,
-    setIsGenerating,
-    isSidebarVisible,
-    openSidebar,
-    closeSidebar,
-    handleSendMessage,
-    handleNewChat,
-    inputRef,
-    autoResizeTextarea,
-  };
-
-  return <ChatContext.Provider value={contextValue}>{children}</ChatContext.Provider>;
-}
-
-// Hook to use the chat context
-export function useChatContext() {
-  const context = useContext(ChatContext);
-  if (context === undefined) {
-    throw new Error(
-      'useChatContext must be used within a ChatProvider. Ensure this component is a child of ChatProvider.'
-    );
-  }
-  return context;
-}
diff --git a/app/hooks/sidebar/useSessionList.ts b/app/hooks/sidebar/useSessionList.ts
new file mode 100644
index 0000000..69abd04
--- /dev/null
+++ b/app/hooks/sidebar/useSessionList.ts
@@ -0,0 +1,98 @@
+import { useMemo } from 'react';
+import { useFireproof } from 'use-fireproof';
+import { FIREPROOF_CHAT_HISTORY } from '../../config/env';
+import type { SessionDocument } from '../../types/chat';
+
+/**
+ * Type to represent either a session document or a screenshot document
+ */
+type SessionOrScreenshot = {
+  _id: string;
+  type?: 'session' | 'screenshot';
+  session_id?: string;
+  title?: string;
+  created_at?: number;
+  _files?: Record<string, any>;
+};
+
+/**
+ * Type for grouped session data including its associated screenshots
+ */
+export type GroupedSession = {
+  session: SessionDocument;
+  screenshots: SessionOrScreenshot[];
+};
+
+/**
+ * Custom hook for retrieving all sessions with their associated screenshots
+ * Uses a single efficient query that gets both data types together
+ * @returns An object containing the grouped sessions and loading state
+ */
+export function useSessionList() {
+  const { database, useLiveQuery } = useFireproof(FIREPROOF_CHAT_HISTORY);
+
+  // Use a single query to fetch both sessions and screenshots with a custom index function
+  // For session docs: returns doc._id
+  // For screenshot docs: returns doc.session_id
+  // This creates a virtual index where sessions and screenshots share the same key value
+  const { docs: sessionAndScreenshots } = useLiveQuery<SessionOrScreenshot>((doc) =>
+    doc.type && doc.type === 'session' ? doc._id : (doc as any).session_id
+  );
+
+  // Group sessions and their associated screenshots together
+  const groupedSessions = useMemo(() => {
+    if (!sessionAndScreenshots || sessionAndScreenshots.length === 0) {
+      return [];
+    }
+
+    const groups = new Map<string, GroupedSession>();
+
+    // Process all documents to group screenshots with their sessions
+    sessionAndScreenshots.forEach((doc) => {
+      if (doc.type === 'screenshot' && doc.session_id) {
+        // Handle screenshot document
+        const sessionId = doc.session_id;
+        let group = groups.get(sessionId);
+
+        if (!group) {
+          // Create a placeholder for this session if it doesn't exist yet
+          group = {
+            session: { _id: sessionId } as SessionDocument,
+            screenshots: [],
+          };
+          groups.set(sessionId, group);
+        }
+
+        // Add screenshot to this session's group
+        group.screenshots.push(doc);
+      } else if (doc.type === 'session') {
+        // Handle session document
+        let group = groups.get(doc._id);
+
+        if (!group) {
+          // Create a new group if this session hasn't been seen yet
+          group = {
+            session: doc as SessionDocument,
+            screenshots: [],
+          };
+          groups.set(doc._id, group);
+        } else {
+          // Update the session data if we already have a group with screenshots
+          group.session = doc as SessionDocument;
+        }
+      }
+    });
+
+    // Convert map to array and sort by created_at (newest first)
+    return Array.from(groups.values()).sort((a, b) => {
+      const timeA = a.session.created_at || 0;
+      const timeB = b.session.created_at || 0;
+      return timeB - timeA;
+    });
+  }, [sessionAndScreenshots]);
+
+  return {
+    groupedSessions,
+    count: groupedSessions.length,
+  };
+}
diff --git a/app/hooks/useChat.ts b/app/hooks/useChat.ts
deleted file mode 100644
index 8121812..0000000
--- a/app/hooks/useChat.ts
+++ /dev/null
@@ -1,390 +0,0 @@
-import { useState, useRef, useCallback, useEffect } from 'react';
-import type { ChatMessage } from '../types/chat';
-import { makeBaseSystemPrompt } from '../prompts';
-import { RegexParser } from '../../RegexParser';
-
-const CHOSEN_MODEL = 'anthropic/claude-3.7-sonnet';
-// const CHOSEN_MODEL = 'qwen/qwq-32b:free';
-
-export function useChat(
-  onCodeGenerated: (code: string, dependencies?: Record<string, string>) => void,
-  onGeneratedTitle?: (title: string) => void
-) {
-  const [messages, setMessages] = useState<ChatMessage[]>([]);
-  const [input, setInput] = useState<string>('');
-  const [isGenerating, setIsGenerating] = useState(false);
-  const [currentStreamedText, setCurrentStreamedText] = useState<string>('');
-  const [systemPrompt, setSystemPrompt] = useState('');
-  const [streamingCode, setStreamingCode] = useState<string>('');
-  const [isStreaming, setIsStreaming] = useState(false);
-  const [completedCode, setCompletedCode] = useState<string>('');
-  const [completedMessage, setCompletedMessage] = useState('');
-  const inputRef = useRef<HTMLTextAreaElement>(null);
-  const messagesEndRef = useRef<HTMLDivElement>(null);
-  const parserState = useRef<RegexParser>(new RegexParser());
-  // Add a ref to store the raw stream data for debugging
-  const rawStreamBuffer = useRef<string>('');
-
-  // Initialize parser when the component mounts
-  useEffect(() => {
-    if (!parserState.current) {
-      parserState.current = new RegexParser();
-    }
-  }, []);
-
-  // Add debug logging whenever messages change, but with a more descriptive context
-  useEffect(() => {
-    // Only log when there's actually a meaningful change, not on initial render
-    // No logging needed
-  }, [messages]);
-
-  // Initialize system prompt
-  useEffect(() => {
-    makeBaseSystemPrompt(CHOSEN_MODEL).then((prompt) => {
-      setSystemPrompt(prompt);
-    });
-  }, []);
-
-  // Auto-resize textarea function
-  const autoResizeTextarea = useCallback(() => {
-    const textarea = inputRef.current;
-    if (textarea) {
-      textarea.style.height = 'auto';
-      textarea.style.height = `${Math.max(60, textarea.scrollHeight)}px`;
-    }
-  }, []);
-
-  const scrollToBottom = useCallback(() => {
-    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
-  }, []);
-
-  // Create a wrapped setMessages function that includes logging
-  const setMessagesWithLogging = useCallback(
-    (newMessages: ChatMessage[] | ((prev: ChatMessage[]) => ChatMessage[])) => {
-      // Only log when there's an actual change
-      if (typeof newMessages === 'function') {
-        setMessages((prev) => {
-          const result = (newMessages as Function)(prev);
-          // Only update if the result is actually different
-          if (JSON.stringify(result) !== JSON.stringify(prev)) {
-            return result;
-          }
-          return prev;
-        });
-      } else {
-        // Only update if the new messages are different
-        setMessages((prev) => {
-          if (JSON.stringify(newMessages) !== JSON.stringify(prev)) {
-            return newMessages;
-          }
-          return prev;
-        });
-      }
-    },
-    [setMessages]
-  );
-
-  // Function to build conversation history for the prompt
-  function buildMessageHistory() {
-    return messages.map((msg) => ({
-      role: msg.type === 'user' ? ('user' as const) : ('assistant' as const),
-      content:
-        msg.type === 'user'
-          ? msg.text
-          : `${msg.text}${
-              msg.code ? `\n\nHere's the code I generated:\n\`\`\`jsx\n${msg.code}\n\`\`\`` : ''
-            }${
-              msg.dependencies && Object.keys(msg.dependencies).length > 0
-                ? `\n\nWith dependencies:\n${JSON.stringify(msg.dependencies, null, 2)}`
-                : ''
-            }`,
-    }));
-  }
-
-  // Initialize parser with event listeners
-  const initParser = useCallback(() => {
-    // Reset the parser state
-    parserState.current.reset();
-
-    // Add event listeners
-    parserState.current.on('text', (textChunk: string, fullText: string) => {
-      setCurrentStreamedText(fullText); // Update with the full displayText from parser
-    });
-
-    parserState.current.on('code', (code: string, language: string) => {
-      setCompletedCode(code);
-    });
-
-    parserState.current.on('codeUpdate', (code: string) => {
-      // Only update streamingCode for significant changes to reduce re-renders
-      if (Math.abs(code.length - streamingCode.length) > 5) {
-        setStreamingCode(code);
-      }
-    });
-
-    parserState.current.on('dependencies', (dependencies: Record<string, string>) => {
-      // Dependencies detected
-    });
-
-    return parserState.current;
-  }, [streamingCode]);
-
-  async function sendMessage() {
-    if (input.trim()) {
-      // Reset state for new message
-      setCurrentStreamedText('');
-      setStreamingCode('');
-      setCompletedCode('');
-      setIsStreaming(true);
-      setIsGenerating(true);
-      // Reset the raw stream buffer
-      rawStreamBuffer.current = '';
-
-      // Add user message
-      setMessages((prev) => [...prev, { text: input, type: 'user' }]);
-      setInput('');
-
-      // Initialize parser
-      const parser = initParser();
-
-      // Track if we've already added the "Writing code..." message
-      let writingCodeMessageAdded = false;
-
-      try {
-        // Build message history
-        const messageHistory = buildMessageHistory();
-
-        // Call OpenRouter API with streaming enabled
-        const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
-          method: 'POST',
-          headers: {
-            Authorization: `Bearer ${import.meta.env.VITE_OPENROUTER_API_KEY}`,
-            'Content-Type': 'application/json',
-            'HTTP-Referer': window.location.origin,
-            'X-Title': 'Fireproof App Builder',
-          },
-          body: JSON.stringify({
-            model: CHOSEN_MODEL,
-            stream: true, // Enable streaming
-            messages: [
-              {
-                role: 'system',
-                content: systemPrompt,
-              },
-              ...messageHistory,
-              {
-                role: 'user',
-                content: input,
-              },
-            ],
-          }),
-        });
-
-        if (!response.ok) {
-          throw new Error(`HTTP error! Status: ${response.status}`);
-        }
-
-        const reader = response.body?.getReader();
-        if (!reader) {
-          throw new Error('Response body is not readable');
-        }
-
-        const decoder = new TextDecoder();
-
-        // Process the stream
-        while (true) {
-          const { done, value } = await reader.read();
-          if (done) break;
-
-          // Decode the chunk
-          const chunk = decoder.decode(value, { stream: true });
-
-          // Process each line (each SSE event)
-          const lines = chunk.split('\n');
-          for (const line of lines) {
-            if (line.startsWith('data: ') && line !== 'data: [DONE]') {
-              try {
-                const data = JSON.parse(line.substring(6));
-                if (data.choices && data.choices[0]?.delta?.content) {
-                  const content = data.choices[0].delta.content;
-
-                  // Capture raw stream data for debugging
-                  rawStreamBuffer.current += content;
-
-                  // Feed the chunk to our parser
-                  parser.write(content);
-
-                  // Direct check for code block markers
-                  if (!writingCodeMessageAdded && content.includes('```')) {
-                    setCurrentStreamedText((prevText) => {
-                      const updatedText = prevText + '\n\n> Writing code...\n\n';
-                      return updatedText;
-                    });
-                    writingCodeMessageAdded = true;
-                  }
-
-                  // Also update streaming code directly from parser's current state
-                  if (parser.inCodeBlock) {
-                    setStreamingCode(parser.codeBlockContent);
-                  }
-                }
-              } catch (e) {
-                console.error('Error parsing chunk:', e);
-              }
-            }
-          }
-        }
-
-        // End the parser stream
-        parser.end();
-
-        // Clean up the message text - use parser's displayText instead of currentStreamedText
-        let cleanedMessage = parser.displayText || currentStreamedText;
-
-        // Clean up any extra whitespace at the beginning
-        cleanedMessage = cleanedMessage.trimStart();
-
-        // Additional cleanup for any JSON artifacts
-        cleanedMessage = cleanedMessage
-          .replace(/^\s*{"dependencies":.*?}}\s*/i, '') // Remove JSON blocks
-          .replace(/^\s*:""[}\s]*/i, '') // Remove artifacts
-          .replace(/^\s*""\s*:\s*""[}\s]*/i, '') // Remove artifacts
-          .trim();
-
-        // If cleanedMessage is still empty but we have code, add a default message
-        if (!cleanedMessage && parser.codeBlockContent) {
-          cleanedMessage = "Here's your code:";
-        }
-
-        // Add AI response with code and dependencies
-        setMessages((prev) => [
-          ...prev,
-          {
-            text: cleanedMessage,
-            type: 'ai',
-            code: parser.codeBlockContent,
-            dependencies: parser.dependencies,
-          },
-        ]);
-
-        // Store the completed message
-        setCompletedMessage(cleanedMessage);
-
-        // Execute callback with generated code if available
-        if (parser.codeBlockContent) {
-          onCodeGenerated(parser.codeBlockContent, parser.dependencies);
-        }
-
-        // Generate a title from the final response
-        if (onGeneratedTitle) {
-          try {
-            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
-              method: 'POST',
-              headers: {
-                Authorization: `Bearer ${import.meta.env.VITE_OPENROUTER_API_KEY}`,
-                'Content-Type': 'application/json',
-                'HTTP-Referer': window.location.origin,
-                'X-Title': 'Fireproof App Builder',
-              },
-              body: JSON.stringify({
-                model: CHOSEN_MODEL,
-                stream: false,
-                messages: [
-                  {
-                    role: 'system',
-                    content:
-                      'You are a helpful assistant that generates short, descriptive titles. Create a concise title (3-5 words) that captures the essence of the content. Return only the title, no other text or markup.',
-                  },
-                  {
-                    role: 'user',
-                    content: `Generate a short, descriptive title (3-5 words) for this app, use the React JSX <h1> tag's value if you can find it:\n\n${rawStreamBuffer.current}`,
-                  },
-                ],
-              }),
-            });
-
-            if (response.ok) {
-              const data = await response.json();
-              const title = data.choices[0]?.message?.content?.trim() || 'New Chat';
-              onGeneratedTitle(title);
-            } else {
-              onGeneratedTitle('New Chat');
-            }
-          } catch (error) {
-            console.error('Error generating title:', error);
-            onGeneratedTitle('New Chat');
-          }
-        }
-
-        // Use parser's displayText property instead of the non-existent fullResponseBuffer
-        const finalMessage =
-          parser.displayText.trim() ||
-          cleanedMessage ||
-          currentStreamedText ||
-          "Here's your generated app:";
-        setCompletedMessage(finalMessage);
-
-        // Update the messages array with more efficient update check
-        setMessagesWithLogging((prevMessages) => {
-          const updatedMessages = [...prevMessages];
-          const lastMessageIndex = updatedMessages.length - 1;
-
-          if (lastMessageIndex >= 0) {
-            // Only update if there's an actual change
-            const currentLastMessage = updatedMessages[lastMessageIndex];
-            const newLastMessage = {
-              ...currentLastMessage,
-              text: finalMessage,
-              streaming: false,
-              completed: true,
-            };
-
-            // Check if the update would actually change anything
-            if (
-              currentLastMessage.text !== newLastMessage.text ||
-              currentLastMessage.streaming !== newLastMessage.streaming ||
-              currentLastMessage.completed !== newLastMessage.completed
-            ) {
-              updatedMessages[lastMessageIndex] = newLastMessage;
-              return updatedMessages;
-            }
-          }
-
-          // Return unchanged if no modifications needed
-          return prevMessages;
-        });
-      } catch (error) {
-        setMessages((prev) => [
-          ...prev,
-          {
-            text: 'Sorry, there was an error generating the component. Please try again.',
-            type: 'ai',
-          },
-        ]);
-        console.error('Error calling OpenRouter API:', error);
-      } finally {
-        setIsGenerating(false);
-        setIsStreaming(false);
-      }
-    }
-  }
-
-  return {
-    messages,
-    setMessages: setMessagesWithLogging,
-    input,
-    setInput,
-    isGenerating,
-    currentStreamedText,
-    streamingCode,
-    completedCode,
-    isStreaming,
-    inputRef,
-    messagesEndRef,
-    autoResizeTextarea,
-    scrollToBottom,
-    sendMessage,
-    parserState,
-    completedMessage,
-  };
-}
diff --git a/app/hooks/useChatSessions.ts b/app/hooks/useChatSessions.ts
deleted file mode 100644
index 564ca81..0000000
--- a/app/hooks/useChatSessions.ts
+++ /dev/null
@@ -1,85 +0,0 @@
-import { useCallback } from 'react';
-import { useFireproof } from 'use-fireproof';
-import type { ChatMessage, SessionDocument } from '../types/chat';
-
-export function useChatSessions(
-  sessionId: string | null = null,
-  onSessionCreated?: (newSessionId: string) => void
-) {
-  const { database } = useFireproof('fireproof-chat-history');
-
-  const saveSession = useCallback(
-    async (sessionMessages: ChatMessage[]) => {
-      if (sessionMessages.length === 0) return;
-
-      // Extract title from first user message
-      const firstUserMessage = sessionMessages.find((msg) => msg.type === 'user');
-      const title = firstUserMessage
-        ? `${firstUserMessage.text.substring(0, 50)}${firstUserMessage.text.length > 50 ? '...' : ''}`
-        : 'Untitled Chat';
-
-      try {
-        // If we have a session ID, fetch the existing document to get its timestamp
-        let existingTimestamp: number | undefined;
-
-        if (sessionId) {
-          try {
-            const existingDoc = (await database.get(sessionId)) as SessionDocument;
-            existingTimestamp = existingDoc.timestamp;
-          } catch (err) {
-            console.error('Error fetching existing session:', err);
-          }
-        }
-
-        // If we have a session ID, update it; otherwise create a new one
-        const sessionData = {
-          title,
-          messages: sessionMessages,
-          // Use existing timestamp if available, otherwise create a new one
-          timestamp: existingTimestamp || Date.now(),
-          ...(sessionId ? { _id: sessionId } : {}),
-        };
-
-        const result = await database.put(sessionData);
-
-        // If this was a new session, notify via callback
-        if (!sessionId && onSessionCreated) {
-          onSessionCreated(result.id);
-        }
-
-        return result.id;
-      } catch (error) {
-        console.error('Error saving session to Fireproof:', error);
-        return null;
-      }
-    },
-    [database, sessionId, onSessionCreated]
-  );
-
-  const loadSession = useCallback(
-    async (session: SessionDocument) => {
-      if (!session?._id) return null;
-
-      try {
-        const sessionData = (await database.get(session._id)) as SessionDocument;
-
-        // Notify via callback if provided
-        if (onSessionCreated) {
-          onSessionCreated(session._id);
-        }
-
-        return sessionData;
-      } catch (err) {
-        console.error('Error loading session:', err);
-        return null;
-      }
-    },
-    [database, onSessionCreated]
-  );
-
-  return {
-    currentSessionId: sessionId,
-    saveSession,
-    loadSession,
-  };
-}
diff --git a/app/hooks/useSession.ts b/app/hooks/useSession.ts
new file mode 100644
index 0000000..6ad9034
--- /dev/null
+++ b/app/hooks/useSession.ts
@@ -0,0 +1,108 @@
+import { useState, useEffect, useCallback, useRef } from 'react';
+import { useFireproof } from 'use-fireproof';
+import { FIREPROOF_CHAT_HISTORY } from '../config/env';
+import type {
+  UserChatMessageDocument,
+  AiChatMessageDocument,
+  SessionDocument,
+  Segment,
+  ScreenshotDocument,
+} from '../types/chat';
+
+export function useSession(routedSessionId: string | undefined) {
+  const { database, useDocument, useLiveQuery } = useFireproof(FIREPROOF_CHAT_HISTORY);
+
+  const {
+    doc: session,
+    merge: mergeSession,
+    save: saveSession,
+  } = useDocument<SessionDocument>(
+    (routedSessionId
+      ? { _id: routedSessionId }
+      : {
+          _id: `${Date.now().toString(36).padStart(9, 'f')}${Math.random().toString(36).slice(2, 11).padEnd(9, '0')}`,
+          type: 'session',
+          title: '',
+          created_at: Date.now(),
+        }) as SessionDocument
+  );
+
+  const {
+    doc: userMessage,
+    merge: mergeUserMessage,
+    save: saveUserMessage,
+    submit: submitUserMessage,
+  } = useDocument<UserChatMessageDocument>({
+    type: 'user',
+    session_id: session._id,
+    text: '',
+    created_at: Date.now(),
+  });
+
+  const {
+    doc: aiMessage,
+    merge: mergeAiMessage,
+    save: saveAiMessage,
+    submit: submitAiMessage,
+  } = useDocument<AiChatMessageDocument>({
+    type: 'ai',
+    session_id: session._id,
+    text: '',
+    created_at: Date.now(),
+  });
+
+  const { docs } = useLiveQuery('session_id', { key: session._id });
+
+  // Update session title
+  const updateTitle = useCallback(
+    async (title: string) => {
+      session.title = title;
+      await database.put(session);
+      mergeSession({ title });
+    },
+    [mergeSession, saveSession]
+  );
+
+  // Add a screenshot to the session
+  const addScreenshot = useCallback(
+    async (screenshotData: string) => {
+      if (!session._id) return;
+
+      const response = await fetch(screenshotData);
+      const blob = await response.blob();
+      const file = new File([blob], 'screenshot.png', {
+        type: 'image/png',
+        lastModified: Date.now(),
+      });
+      const screenshot = {
+        type: 'screenshot',
+        session_id: session._id,
+        _files: {
+          screenshot: file,
+        },
+      };
+      console.log('add screenshot', screenshot);
+      await database.put(screenshot);
+    },
+    [session._id, database]
+  );
+
+  // const { docs: screenshots } = useLiveQuery<ScreenshotDocument>((doc) => [doc.session_id, doc.type], { prefix: [ 'screenshot' ] });
+
+  return {
+    session,
+    docs,
+    // screenshots,
+    database,
+    updateTitle,
+    addScreenshot,
+    userMessage,
+    submitUserMessage,
+    mergeUserMessage,
+    // updateAiMessage,
+    aiMessage,
+    submitAiMessage,
+    mergeAiMessage,
+    saveAiMessage,
+  };
+}
diff --git a/app/hooks/useSimpleChat.ts b/app/hooks/useSimpleChat.ts
new file mode 100644
index 0000000..cdc4361
--- /dev/null
+++ b/app/hooks/useSimpleChat.ts
@@ -0,0 +1,173 @@
+import { useState, useRef, useCallback, useEffect, useMemo } from 'react';
+import type { Segment, ChatMessageDocument, ChatState, ScreenshotDocument } from '../types/chat';
+import { makeBaseSystemPrompt } from '../prompts';
+import { parseContent, parseDependencies } from '../utils/segmentParser';
+import { useSession } from './useSession';
+import { generateTitle } from '../utils/titleGenerator';
+import { processStream, callOpenRouterAPI } from '../utils/streamHandler';
+
+const CODING_MODEL = 'anthropic/claude-3.7-sonnet';
+const TITLE_MODEL = 'google/gemini-2.0-flash-lite-001';
+/**
+ * Simplified chat hook that focuses on data-driven state management
+ * Uses session-based architecture with individual message documents
+ * @returns ChatState object with all chat functionality and state
+ */
+export function useSimpleChat(sessionId: string | undefined): ChatState {
+  const {
+    session,
+    updateTitle,
+    docs,
+    userMessage,
+    mergeUserMessage,
+    submitUserMessage,
+    mergeAiMessage,
+    addScreenshot,
+    // screenshots,
+    database,
+    aiMessage,
+  } = useSession(sessionId);
+  const [systemPrompt, setSystemPrompt] = useState('');
+  const streamBufferRef = useRef<string>('');
+  const inputRef = useRef<HTMLTextAreaElement>(null);
+  const [isStreaming, setIsStreaming] = useState<boolean>(false);
+  const [selectedResponseId, setSelectedResponseId] = useState<string>(''); // default most recent
+
+  const selectedResponseDoc = (isStreaming
+    ? aiMessage
+    : docs.find((doc: any) => doc.type === 'ai' && doc._id === selectedResponseId) ||
+      docs.filter((doc: any) => doc.type === 'ai').reverse()[0]) as unknown as ChatMessageDocument;
+
+  const setInput = useCallback((input: string) => {
+    mergeUserMessage({ text: input });
+  }, [mergeUserMessage]);
+
+  // Process docs into messages for the UI
+  const filteredDocs = docs.filter((doc: any) => doc.type === 'ai' || doc.type === 'user');
+
+  const messages = (isStreaming && aiMessage.text.length > 0
+    ? [...filteredDocs, aiMessage]
+    : filteredDocs) as unknown as ChatMessageDocument[];
+
+  const buildMessageHistory = useCallback(() => {
+    return messages.map((msg) => ({
+      role: msg.type === 'user' ? ('user' as const) : ('assistant' as const),
+      content: msg.text || '',
+    }));
+  }, [messages]);
+
+  const { segments: selectedSegments, dependenciesString: selectedDependenciesString } =
+    selectedResponseDoc
+      ? parseContent(selectedResponseDoc.text)
+      : { segments: [], dependenciesString: '' };
+
+  const selectedCode =
+    selectedSegments.find((segment) => segment.type === 'code') || ({ content: '' } as Segment);
+
+  const selectedDependencies = selectedDependenciesString
+    ? parseDependencies(selectedDependenciesString)
+    : {};
+  /**
+   * Send a message and process the AI response
+   * Returns a promise that resolves when the entire process is complete, including title generation
+   */
+  const sendMessage = useCallback(async (): Promise<void> => {
+    if (!userMessage.text.trim()) return;
+
+    // First, ensure we have the system prompt
+    // Instead of setting state and immediately using it, get the value and use it directly
+    let currentSystemPrompt = systemPrompt;
+    if (!currentSystemPrompt) {
+      if (import.meta.env.MODE === 'test') {
+        currentSystemPrompt = 'Test system prompt';
+        setSystemPrompt(currentSystemPrompt);
+      } else {
+        currentSystemPrompt = await makeBaseSystemPrompt(CODING_MODEL);
+        setSystemPrompt(currentSystemPrompt);
+      }
+    }
+
+    // Reset stream buffer and set streaming state
+    streamBufferRef.current = '';
+    setIsStreaming(true);
+
+    // Submit user message first
+    return submitUserMessage()
+      .then(() => {
+        const messageHistory = buildMessageHistory();
+        // Use the locally captured system prompt value, not the state variable
+        return callOpenRouterAPI(
+          CODING_MODEL,
+          currentSystemPrompt,
+          messageHistory,
+          userMessage.text
+        );
+      })
+      .then((response) => {
+        return processStream(response, (content) => {
+          streamBufferRef.current += content;
+          mergeAiMessage({ text: streamBufferRef.current });
+        });
+      })
+      .then(async () => {
+        aiMessage.text = streamBufferRef.current;
+        // mergeAiMessage({ text: streamBufferRef.current });
+        const ok = await database.put(aiMessage);
+      })
+      .then(() => {
+        const { segments } = parseContent(aiMessage.text);
+        if (!session?.title) {
+          return generateTitle(segments, TITLE_MODEL).then(updateTitle);
+        }
+      })
+      .catch((error) => {
+        console.error('Error processing stream:', error);
+      })
+      .finally(() => {
+        setIsStreaming(false);
+      });
+  }, [
+    userMessage.text,
+    systemPrompt,
+    setSystemPrompt,
+    streamBufferRef,
+    setIsStreaming,
+    submitUserMessage,
+    buildMessageHistory,
+    mergeAiMessage,
+    aiMessage,
+    database,
+    session?.title,
+    updateTitle
+  ]);
+
+  const addFirstScreenshot = useCallback(async (screenshotData: string) => {
+    const { rows: screenshots } = await database.query((doc: any) => [doc.session_id, doc.type], {
+      key: [session._id, 'screenshot'],
+    });
+    if (screenshots.length === 0) {
+      addScreenshot(screenshotData);
+    }
+  }, [session._id, database, addScreenshot]);
+
+  const codeReady = useMemo(() => {
+    return !isStreaming || selectedSegments.length > 2;
+  }, [isStreaming, selectedSegments]);
+
+  return {
+    sessionId: session._id,
+    addScreenshot,
+    docs: messages,
+    selectedResponseDoc,
+    selectedSegments,
+    selectedCode,
+    selectedDependencies,
+    input: userMessage.text,
+    setInput,
+    isStreaming,
+    codeReady,
+    sendMessage,
+    inputRef,
+    title: session?.title || '',
+  };
+}
diff --git a/app/prompts.ts b/app/prompts.ts
index fa8510c..5a6de78 100644
--- a/app/prompts.ts
+++ b/app/prompts.ts
@@ -43,7 +43,7 @@ If you need any npm dependencies, list them at the start of your response in thi
   "another-package": "version"
 }}
 
-Then provide a brief explanation followed by the component code. The component should demonstrate proper Fireproof integration with real-time updates and proper data persistence. 
+Then provide a title and brief explanation followed by the component code. The component should demonstrate proper Fireproof integration with real-time updates and proper data persistence. Follow it with a longer description of the app's purpose and detailed instructions how to use it (with occasional bold or italic for emphasis). 
 
 Begin the component with the import statements. Use react and use-fireproof:
 
diff --git a/app/routes.ts b/app/routes.ts
index 37a3a98..8406c6b 100644
--- a/app/routes.ts
+++ b/app/routes.ts
@@ -2,5 +2,5 @@ import { type RouteConfig, index, route } from '@react-router/dev/routes';
 
 export default [
   index('./routes/home.tsx'),
-  route('session/:sessionId/:title?', './routes/session.tsx'),
+  route('chat/:sessionId/:title?', './routes/home.tsx', { id: 'chat' }),
 ] satisfies RouteConfig;
diff --git a/app/routes/home.tsx b/app/routes/home.tsx
index a9dd198..3ad738d 100644
--- a/app/routes/home.tsx
+++ b/app/routes/home.tsx
@@ -1,10 +1,13 @@
-import { useEffect, useState, useCallback, useMemo, useRef } from 'react';
-import { useNavigate } from 'react-router';
-import ChatInterface from '../ChatInterface';
+import { useEffect, useState, useCallback } from 'react';
+import { useParams, useNavigate, useLocation } from 'react-router';
+import ChatInterface from '../components/ChatInterface';
 import ResultPreview from '../components/ResultPreview/ResultPreview';
-import { useChat } from '../hooks/useChat';
-import { useFireproof } from 'use-fireproof';
-import { ChatProvider } from '../context/ChatContext';
+import ChatHeaderContent from '../components/ChatHeaderContent';
+import ResultPreviewHeaderContent from '../components/ResultPreview/ResultPreviewHeaderContent';
+import { useSimpleChat } from '../hooks/useSimpleChat';
+import AppLayout from '../components/AppLayout';
+import { decodeStateFromUrl } from '../utils/sharing';
+import { encodeTitle } from '~/components/SessionSidebar/utils';
 
 export function meta() {
   return [
@@ -13,381 +16,88 @@ export function meta() {
   ];
 }
 
-// Utility functions for URL state encoding/decoding
-function encodeStateToUrl(code: string, dependencies: Record<string, string>) {
-  try {
-    const stateObj = { code, dependencies };
-    const jsonStr = JSON.stringify(stateObj);
-    const encoded = btoa(encodeURIComponent(jsonStr));
-    return encoded;
-  } catch (error) {
-    console.error('Error encoding state to URL:', error);
-    return '';
-  }
-}
-
-function decodeStateFromUrl(encoded: string) {
-  try {
-    const jsonStr = decodeURIComponent(atob(encoded));
-    const stateObj = JSON.parse(jsonStr);
-    return {
-      code: stateObj.code || '',
-      dependencies: stateObj.dependencies || {},
-    };
-  } catch (error) {
-    console.error('Error decoding state from URL:', error);
-    return { code: '', dependencies: {} };
-  }
-}
-
-export default function Home() {
-  const [state, setState] = useState({
-    generatedCode: '',
-    dependencies: {} as Record<string, string>,
-  });
-  const [shareStatus, setShareStatus] = useState<string>('');
-  const [isSharedApp, setIsSharedApp] = useState<boolean>(false);
-  const [sessionId, setSessionId] = useState<string | null>(null);
-  const [pendingTitle, setPendingTitle] = useState<string | null>(null);
-  const [isCreatingSession, setIsCreatingSession] = useState(false);
-  const { database } = useFireproof('fireproof-chat-history');
+export default function UnifiedSession() {
+  const { sessionId: urlSessionId } = useParams<{ sessionId: string }>();
   const navigate = useNavigate();
-
-  // Keep tracking streaming props with refs to avoid re-renders
-  const streamingPropsRef = useRef({
-    streamingCode: '',
-    isStreaming: false,
-    currentStreamedText: '',
-    messages: [] as any[],
-  });
-
-  // Maintain a stable ref to the database to prevent re-renders
-  const databaseRef = useRef(database);
-
-  // Update database ref when it changes
-  useEffect(() => {
-    databaseRef.current = database;
-  }, [database]);
-
-  // Hoist the useChat hook to this component with stable callback reference
-  const handleCodeGenerated = useCallback((code: string, dependencies?: Record<string, string>) => {
-    setState({
-      generatedCode: code,
-      dependencies: dependencies || {},
-    });
+  const location = useLocation();
+  const chatState = useSimpleChat(urlSessionId);
+  
+  // State for view management
+  const [activeView, setActiveView] = useState<'code' | 'preview'>('code');
+  const [previewReady, setPreviewReady] = useState(false);
+  const [bundlingComplete, setBundlingComplete] = useState(true);
+  const [isSidebarVisible, setIsSidebarVisible] = useState(false);
+
+  // Directly create an openSidebar function
+  const openSidebar = useCallback(() => {
+    setIsSidebarVisible(true);
   }, []);
 
-  // Handle the generated title callback
-  const handleGeneratedTitle = useCallback(
-    async (generatedTitle: string) => {
-      // Handle the generated title
-
-      // Safety check - don't proceed if title is undefined
-      if (!generatedTitle) {
-        console.warn('Skipping title update - received undefined title');
-        return;
-      }
-
-      if (sessionId) {
-        try {
-          // Get the current session document
-          const sessionDoc = await databaseRef.current.get(sessionId);
-
-          // Validate sessionDoc before updating
-          if (!sessionDoc) {
-            console.error('Cannot update title: session document is missing');
-            return;
-          }
-
-          // Create a safe update object without undefined values
-          const updatedDoc = {
-            ...sessionDoc,
-            title: generatedTitle || 'Untitled Chat', // Ensure title is never undefined
-          };
-
-          // Save the updated document
-          await databaseRef.current.put(updatedDoc);
-        } catch (error) {
-          console.error('Error updating session title:', error);
-        }
-      } else {
-        // If no sessionId yet, store the title for later use
-        setPendingTitle(generatedTitle);
-      }
-    },
-    [sessionId, isCreatingSession]
-  );
-
-  const chatState = useChat(handleCodeGenerated, handleGeneratedTitle);
-
-  // Only update refs when values actually change with deep equality check
-  useEffect(() => {
-    const currentProps = {
-      streamingCode: chatState.streamingCode,
-      isStreaming: chatState.isStreaming,
-      currentStreamedText: chatState.currentStreamedText,
-      messages: chatState.messages,
-    };
-
-    // Deep comparison to avoid unnecessary updates
-    const hasStreamingChanged = chatState.isStreaming !== streamingPropsRef.current.isStreaming;
-    const hasStreamingCodeChanged =
-      chatState.streamingCode !== streamingPropsRef.current.streamingCode;
-    const hasCurrentStreamedTextChanged =
-      chatState.currentStreamedText !== streamingPropsRef.current.currentStreamedText;
-    const hasMessagesChanged =
-      chatState.messages.length !== streamingPropsRef.current.messages.length ||
-      JSON.stringify(chatState.messages) !== JSON.stringify(streamingPropsRef.current.messages);
-
-    // Only update if something changed
-    if (
-      hasStreamingChanged ||
-      hasStreamingCodeChanged ||
-      hasCurrentStreamedTextChanged ||
-      hasMessagesChanged
-    ) {
-      streamingPropsRef.current = currentProps;
-    }
-  }, [
-    chatState.streamingCode,
-    chatState.isStreaming,
-    chatState.currentStreamedText,
-    chatState.messages,
-  ]);
+  // Handle preview loaded event
+  const handlePreviewLoaded = useCallback(() => {
+    setPreviewReady(true);
+  }, []);
 
-  // Apply pending title when sessionId becomes available
   useEffect(() => {
-    if (!sessionId || !pendingTitle) return;
-
-    // Skip update if we're in the process of creating a session
-    if (isCreatingSession) {
-      return;
-    }
-
-    const updateTitleWhenReady = async () => {
-      try {
-        // Get the current session document
-        const sessionDoc = await databaseRef.current.get(sessionId);
-
-        // Create a safe update object without undefined values
-        const updatedDoc = {
-          ...sessionDoc,
-          title: pendingTitle || 'Untitled Chat',
-        };
-
-        // Save the updated document
-        await databaseRef.current.put(updatedDoc);
-
-        // Clear the pending title after successful update
-        setPendingTitle(null);
-      } catch (error) {
-        console.error('Error updating session title:', error);
+    if (chatState.title) {
+      const newUrl = `/chat/${chatState.sessionId}/${encodeTitle(chatState.title)}`;
+      if (newUrl !== location.pathname) {
+        navigate(newUrl, { replace: true });
       }
-    };
-
-    updateTitleWhenReady();
-  }, [sessionId, pendingTitle, isCreatingSession]);
+    }
+  }, [chatState.title]);
 
-  // Check for state in URL on component mount
+  // Check if there's a state parameter in the URL (for shared apps)
   useEffect(() => {
-    const hash = window.location.hash;
-    if (hash?.startsWith('#state=')) {
-      const encodedState = hash.substring(7); // Remove '#state='
+    const searchParams = new URLSearchParams(location.search);
+    const encodedState = searchParams.get('state');
+    if (encodedState) {
       const decodedState = decodeStateFromUrl(encodedState);
       if (decodedState.code) {
-        setState({
-          generatedCode: decodedState.code,
-          dependencies: decodedState.dependencies,
-        });
-        setIsSharedApp(true);
+        console.log('UnifiedSession: decodedState share:', decodedState);
       }
     }
-  }, []);
-
-  // Handle new session creation
-  const handleSessionCreated = useCallback((newSessionId: string) => {
-    setSessionId(newSessionId);
-    // We don't need to navigate here, as the ChatInterface will do that
-  }, []);
-
-  // Handle new chat (reset session)
-  const handleNewChat = useCallback(() => {
-    setSessionId(null);
-    setShareStatus('');
-    setState({
-      generatedCode: '',
-      dependencies: {},
-    });
-    chatState.setMessages([]);
-  }, [chatState]);
-
-  function handleShare() {
-    if (!state.generatedCode) {
-      alert('Generate an app first before sharing!');
-      return;
-    }
-
-    const encoded = encodeStateToUrl(state.generatedCode, state.dependencies);
-    if (encoded) {
-      const shareUrl = `${window.location.origin}${window.location.pathname}#state=${encoded}`;
-
-      // Use optional chaining for Web Share API check
-      const canUseShareApi = Boolean(navigator && 'share' in navigator);
+  }, [location.search]);
 
-      if (canUseShareApi) {
-        navigator
-          .share({
-            title: 'Fireproof App',
-            text: 'Check out this app I built with Fireproof App Builder!',
-            url: shareUrl,
-          })
-          .catch(() => {
-            copyToClipboard(shareUrl);
-          });
-      } else {
-        copyToClipboard(shareUrl);
+  return (
+    <AppLayout
+      headerLeft={
+        <ChatHeaderContent 
+          onOpenSidebar={openSidebar} 
+          title={chatState.title || 'New Chat'} 
+        />
       }
-    }
-  }
-
-  function copyToClipboard(text: string) {
-    navigator.clipboard
-      .writeText(text)
-      .then(() => {
-        setShareStatus('Copied to clipboard!');
-        setTimeout(() => setShareStatus(''), 3000);
-      })
-      .catch((err) => {
-        console.error('Failed to copy: ', err);
-        // Further fallback - show the URL to manually copy
-        prompt('Copy this link to share your app:', text);
-      });
-  }
-
-  // Add screenshot handling in home.tsx
-  const handleScreenshotCaptured = useCallback(
-    async (screenshotData: string) => {
-      if (sessionId) {
-        const response = await fetch(screenshotData);
-        const blob = await response.blob();
-        const file = new File([blob], 'screenshot.png', { type: 'image/png' });
-
-        await databaseRef.current.put({
-          type: 'screenshot',
-          session_id: sessionId,
-          _files: {
-            screenshot: file,
-          },
-        });
+      headerRight={
+        <ResultPreviewHeaderContent
+          previewReady={previewReady}
+          activeView={activeView}
+          setActiveView={setActiveView}
+          bundlingComplete={bundlingComplete}
+          isStreaming={chatState.isStreaming}
+          code={chatState.selectedCode?.content || ''}
+          dependencies={chatState.selectedDependencies || {}}
+        />
       }
-    },
-    [sessionId]
-  );
-
-  // Memoize dependencies to prevent unnecessary re-renders
-  const previewDependencies = useMemo(() => {
-    return chatState.parserState?.current?.dependencies || state.dependencies;
-  }, [chatState.parserState?.current?.dependencies, state.dependencies]);
-
-  // Memoized ChatInterface component with refined dependencies
-  const memoizedChatInterface = useMemo(() => {
-    return (
-      <ChatProvider
-        initialState={{
-          input: '',
-          isGenerating: false,
-          isSidebarVisible: false,
-        }}
-        onSendMessage={(input) => {
-          if (input.trim()) {
-            if (!sessionId) {
-              // If no session exists, create one
-              setIsCreatingSession(true);
-              const newSession = {
-                timestamp: Date.now(),
-                title: input.length > 50 ? `${input.substring(0, 50)}...` : input,
-              };
-
-              databaseRef.current
-                .put(newSession)
-                .then((doc: { id: string }) => {
-                  handleSessionCreated(doc.id);
-                  setIsCreatingSession(false);
-                })
-                .catch((err: Error) => {
-                  console.error('Error creating session:', err);
-                  setIsCreatingSession(false);
-                });
-            }
-          }
-        }}
-        onNewChat={handleNewChat}
-      >
-        <ChatInterface
-          chatState={chatState}
-          sessionId={sessionId}
-          onSessionCreated={handleSessionCreated}
-          onNewChat={handleNewChat}
-          onCodeGenerated={handleCodeGenerated}
+      chatPanel={
+        <ChatInterface 
+          {...chatState}
+          isSidebarVisible={isSidebarVisible}
+          setIsSidebarVisible={setIsSidebarVisible}
         />
-      </ChatProvider>
-    );
-  }, [
-    sessionId,
-    handleSessionCreated,
-    handleNewChat,
-    handleCodeGenerated,
-    setIsCreatingSession,
-    // Avoid including the entire chatState to prevent unnecessary re-renders
-    // Only include specific parts that affect the UI
-    chatState.sendMessage,
-    chatState.isGenerating,
-  ]);
-
-  // Memoized ResultPreview component with improved dependency handling
-  const memoizedResultPreview = useMemo(() => {
-    return (
-      <ResultPreview
-        code={state.generatedCode}
-        streamingCode={streamingPropsRef.current.streamingCode}
-        isStreaming={streamingPropsRef.current.isStreaming}
-        dependencies={previewDependencies}
-        onShare={handleShare}
-        shareStatus={shareStatus}
-        completedMessage={chatState.completedMessage}
-        currentStreamContent={streamingPropsRef.current.currentStreamedText}
-        currentMessage={
-          streamingPropsRef.current.messages.length > 0
-            ? {
-                content:
-                  streamingPropsRef.current.messages[streamingPropsRef.current.messages.length - 1]
-                    .text,
-              }
-            : undefined
-        }
-        onScreenshotCaptured={handleScreenshotCaptured}
-        {...(sessionId ? { sessionId } : {})}
-      />
-    );
-  }, [
-    state.generatedCode,
-    previewDependencies,
-    sessionId,
-    shareStatus,
-    handleShare,
-    handleScreenshotCaptured,
-    chatState.completedMessage,
-    // Removed streaming-related props since we use the ref versions
-  ]);
-
-  return (
-    <div style={{ display: 'flex', height: 'calc(100vh)' }}>
-      <div style={{ flex: '0 0 33.333%', overflow: 'hidden', position: 'relative' }}>
-        {memoizedChatInterface}
-      </div>
-      <div style={{ flex: '0 0 66.667%', overflow: 'hidden', position: 'relative' }}>
-        {memoizedResultPreview}
-      </div>
-    </div>
+      }
+      previewPanel={
+        <ResultPreview
+          sessionId={chatState.sessionId || ''}
+          code={chatState.selectedCode?.content || ''}
+          dependencies={chatState.selectedDependencies || {}}
+          isStreaming={chatState.isStreaming}
+          codeReady={chatState.codeReady}
+          onScreenshotCaptured={chatState.addScreenshot}
+          activeView={activeView}
+          setActiveView={setActiveView}
+          onPreviewLoaded={handlePreviewLoaded}
+        />
+      }
+    />
   );
 }
diff --git a/app/routes/session.tsx b/app/routes/session.tsx
deleted file mode 100644
index d218384..0000000
--- a/app/routes/session.tsx
+++ /dev/null
@@ -1,137 +0,0 @@
-import { useEffect, useState, useRef, useCallback } from 'react';
-import { useParams } from 'react-router';
-import ChatInterface from '../ChatInterface';
-import { useChat } from '../hooks/useChat';
-import { useFireproof } from 'use-fireproof';
-import { ChatProvider } from '../context/ChatContext';
-import ResultPreview from '../components/ResultPreview/ResultPreview';
-import type { ChatMessage, SessionDocument } from '../types/chat';
-
-export function meta() {
-  return [
-    { title: 'Session - Fireproof App Builder' },
-    { name: 'description', content: 'Chat session in Fireproof App Builder' },
-  ];
-}
-
-export default function Session() {
-  const { sessionId, title } = useParams();
-
-  const [state, setState] = useState({
-    generatedCode: '',
-    dependencies: {} as Record<string, string>,
-  });
-  const { database } = useFireproof('fireproof-chat-history');
-
-  // Maintain a stable ref to the database to prevent re-renders
-  const databaseRef = useRef(database);
-
-  // Update database ref when it changes
-  useEffect(() => {
-    databaseRef.current = database;
-  }, [database]);
-
-  // Handle code generation from chat interface with stable callback reference
-  const handleCodeGenerated = useCallback(
-    (code: string, dependencies: Record<string, string> = {}) => {
-      setState({
-        generatedCode: code,
-        dependencies,
-      });
-    },
-    []
-  );
-
-  // Set up chat state with the code generation handler
-  const chatState = useChat(handleCodeGenerated);
-
-  // Create a ref to chatState to avoid dependency cycles
-  const chatStateRef = useRef(chatState);
-
-  // Update the ref when chatState changes
-  useEffect(() => {
-    chatStateRef.current = chatState;
-  }, [chatState]);
-
-  // Handle session change
-  useEffect(() => {
-    // Load session data and extract code for the ResultPreview
-    const loadSessionData = async () => {
-      if (sessionId) {
-        try {
-          // Load the session document
-          const sessionData = (await databaseRef.current.get(sessionId)) as SessionDocument;
-
-          // Normalize session data to guarantee messages array exists
-          const messages = Array.isArray(sessionData.messages) ? sessionData.messages : [];
-
-          // Clear current messages and set the loaded ones
-          chatStateRef.current.setMessages(messages);
-
-          // Find the last AI message with code to update the ResultPreview
-          const lastAiMessageWithCode = [...messages]
-            .reverse()
-            .find((msg: ChatMessage) => msg.type === 'ai' && msg.code);
-
-          // If we found an AI message with code, update the code view
-          if (lastAiMessageWithCode?.code) {
-            const dependencies = lastAiMessageWithCode.dependencies || {};
-
-            // Update state for ResultPreview
-            setState({
-              generatedCode: lastAiMessageWithCode.code,
-              dependencies: dependencies,
-            });
-
-            // Use the ref to update chat state properties
-            chatStateRef.current.completedCode = lastAiMessageWithCode.code;
-            chatStateRef.current.streamingCode = lastAiMessageWithCode.code;
-            chatStateRef.current.completedMessage =
-              lastAiMessageWithCode.text || "Here's your app:";
-          }
-        } catch (error) {
-          console.error('Error loading session:', error);
-        }
-      }
-    };
-
-    loadSessionData();
-  }, [sessionId, databaseRef]); // Removed chatState from dependencies
-
-  return (
-    <div style={{ display: 'flex', height: 'calc(100vh)' }}>
-      <div style={{ flex: '0 0 33.333%', overflow: 'hidden', position: 'relative' }}>
-        <ChatProvider
-          initialState={{
-            input: '',
-            isGenerating: false,
-            isSidebarVisible: false,
-          }}
-        >
-          <ChatInterface
-            chatState={chatState}
-            sessionId={sessionId || null}
-            onCodeGenerated={handleCodeGenerated}
-          />
-        </ChatProvider>
-      </div>
-      <div style={{ flex: '0 0 66.667%', overflow: 'hidden', position: 'relative' }}>
-        <ResultPreview
-          code={state.generatedCode}
-          dependencies={state.dependencies}
-          streamingCode={chatState.streamingCode}
-          isStreaming={chatState.isStreaming}
-          completedMessage={chatState.completedMessage}
-          currentStreamContent={chatState.currentStreamedText}
-          currentMessage={
-            chatState.messages.length > 0
-              ? { content: chatState.messages[chatState.messages.length - 1].text }
-              : undefined
-          }
-          initialView="code"
-          sessionId={sessionId}
-        />
-      </div>
-    </div>
-  );
-}
diff --git a/app/tests/ChatInterface.test.tsx b/app/tests/ChatInterface.test.tsx
deleted file mode 100644
index a1efae2..0000000
--- a/app/tests/ChatInterface.test.tsx
+++ /dev/null
@@ -1,63 +0,0 @@
-import React from 'react';
-import { render } from '@testing-library/react';
-import ChatInterface from '../ChatInterface';
-import { vi, describe, test, expect } from 'vitest';
-import { ChatProvider } from '../context/ChatContext';
-
-/**
- * Tests for the ChatInterface component
- * This file verifies the fix for the 'input is not defined' error in ChatInterface.tsx
- */
-
-// Mock the useFireproof hook
-vi.mock('use-fireproof', () => ({
-  useFireproof: () => ({
-    database: {},
-    useLiveQuery: () => ({ docs: [] }),
-  }),
-}));
-
-// Prepare mock data
-const mockChatState = {
-  messages: [],
-  setMessages: vi.fn(),
-  input: 'test input',
-  setInput: vi.fn(),
-  isGenerating: false,
-  currentStreamedText: '',
-  streamingCode: '',
-  completedCode: '',
-  isStreaming: false,
-  inputRef: { current: null },
-  messagesEndRef: { current: null },
-  autoResizeTextarea: vi.fn(),
-  scrollToBottom: vi.fn(),
-  sendMessage: vi.fn(),
-  parserState: {
-    current: {
-      inCodeBlock: false,
-      codeBlockContent: '',
-      dependencies: {},
-      displayText: '',
-      on: vi.fn(),
-      removeAllListeners: vi.fn(),
-      write: vi.fn(),
-      end: vi.fn(),
-      reset: vi.fn(),
-    },
-  },
-  completedMessage: '',
-};
-
-describe('ChatInterface', () => {
-  test('renders without error after fixing input destructuring', () => {
-    // This test passes now that we've fixed the 'input is not defined' error
-    // by properly destructuring input from chatState
-    const { container } = render(
-      <ChatProvider>
-        <ChatInterface chatState={mockChatState} />
-      </ChatProvider>
-    );
-    expect(container).toBeDefined();
-  });
-});
diff --git a/app/types/chat.ts b/app/types/chat.ts
index 6e55589..7a93ec6 100644
--- a/app/types/chat.ts
+++ b/app/types/chat.ts
@@ -1,50 +1,119 @@
-export interface ChatMessage {
+import type { DocTypes } from 'use-fireproof';
+import type { GroupedSession } from '../hooks/sidebar/useSessionList';
+
+// ===== Content Segment Types =====
+export type Segment = {
+  type: 'markdown' | 'code';
+  content: string;
+};
+
+// ===== Document Types =====
+
+export type BaseChatMessageDocument = {
+  _id?: string;
+  session_id: string;
   text: string;
-  type: 'user' | 'ai';
-  code?: string;
-  dependencies?: Record<string, string>;
-  streaming?: boolean;
-  completed?: boolean;
-}
+  created_at: number;
+};
+
+export type UserChatMessageDocument = BaseChatMessageDocument & {
+  type: 'user';
+};
+
+export type AiChatMessageDocument = BaseChatMessageDocument & {
+  type: 'ai';
+};
 
-export interface SessionDocument {
+export type ChatMessageDocument = UserChatMessageDocument | AiChatMessageDocument;
+
+/**
+ * Base document interface with common properties
+ */
+export interface DocBase {
   _id: string;
+}
+
+/**
+ * Document type for screenshot entries
+ */
+export interface ScreenshotDocument extends DocBase {
+  type: 'screenshot';
+  session_id: string;
+  _files?: {
+    screenshot: { file: () => Promise<File>; type: string };
+  };
+}
+
+// Note: We already have a SessionDocument interface, so merged the properties
+export interface SessionDocument extends DocTypes {
+  _id?: string;
+  type: 'session'; // Document type for Fireproof queries
   title?: string;
-  timestamp: number;
-  messages?: ChatMessage[];
+  created_at: number;
+  messages?: Array<{
+    text: string;
+    type: 'user' | 'ai';
+    code?: string;
+    dependencies?: Record<string, string>;
+  }>;
+}
+
+/**
+ * Union type for documents returned by query
+ */
+export type SessionOrScreenshot = SessionDocument | ScreenshotDocument;
+
+// ===== UI Enhanced Types =====
+// Enhanced types with additional UI properties
+export type ChatMessage = ChatMessageDocument & {
+  text: string;
+  timestamp?: number;
+};
+
+// User chat message type used in the UI
+export type UserChatMessage = ChatMessage & {
+  type: 'user';
+};
+
+// Enhanced AiChatMessage type with segments for structured display
+export type AiChatMessage = ChatMessage & {
+  type: 'ai';
+  segments?: Segment[];
+  isStreaming?: boolean;
+  dependenciesString?: string;
+};
+
+// ===== Component Props =====
+export interface ChatState {
+  docs: ChatMessageDocument[];
+  input: string;
+  setInput: (input: string) => void;
+  isStreaming: boolean;
+  codeReady: boolean;
+  inputRef: React.RefObject<HTMLTextAreaElement | null>;
+  sendMessage: () => Promise<void>;
+  title: string;
+  addScreenshot: (screenshot: string) => Promise<void>;
+  sessionId?: string | null;
+  selectedResponseDoc?: ChatMessageDocument;
+  selectedSegments?: Segment[];
+  selectedCode?: Segment;
+  selectedDependencies?: Record<string, string>;
 }
 
 export interface ChatInterfaceProps {
-  chatState: {
-    messages: ChatMessage[];
-    setMessages: React.Dispatch<React.SetStateAction<ChatMessage[]>>;
-    input: string;
-    setInput: React.Dispatch<React.SetStateAction<string>>;
-    isGenerating: boolean;
-    currentStreamedText: string;
-    streamingCode: string;
-    completedCode: string;
-    isStreaming: boolean;
-    inputRef: React.RefObject<HTMLTextAreaElement | null>;
-    messagesEndRef: React.RefObject<HTMLDivElement | null>;
-    autoResizeTextarea: () => void;
-    scrollToBottom: () => void;
-    sendMessage: () => Promise<void>;
-    parserState: React.MutableRefObject<{
-      inCodeBlock: boolean;
-      codeBlockContent: string;
-      dependencies: Record<string, string>;
-      displayText: string;
-      on: (event: string, callback: Function) => void;
-      removeAllListeners: () => void;
-      write: (chunk: string) => void;
-      end: () => void;
-      reset: () => void;
-    }>;
-    completedMessage: string;
-  };
+  chatState: ChatState;
   sessionId?: string | null;
   onSessionCreated?: (newSessionId: string) => void;
-  onNewChat?: () => void;
-  onCodeGenerated?: (code: string, dependencies?: Record<string, string>) => void;
 }
+
+/**
+ * Props for the SessionSidebar component
+ */
+export interface SessionSidebarProps {
+  isVisible: boolean;
+  onClose: () => void;
+  sessionId: string;
+}
+
+export type { GroupedSession };
diff --git a/app/utils/debugLogging.ts b/app/utils/debugLogging.ts
new file mode 100644
index 0000000..da18348
--- /dev/null
+++ b/app/utils/debugLogging.ts
@@ -0,0 +1,145 @@
+/**
+ * Debug logging utility for streaming content
+ *
+ * This file provides consistent logging for both tests and production code.
+ * It enables tracking the flow of streaming content and component rendering
+ * to ensure consistent behavior across environments.
+ */
+
+// Always enable debug in test environment
+const DEBUG_ENABLED =
+  process.env.NODE_ENV === 'development' ||
+  process.env.NODE_ENV === 'test' ||
+  process.env.VITEST === 'true';
+
+// Force log output in tests
+const FORCE_LOG_IN_TESTS = true;
+
+// Simple counter for tracking streaming updates
+let updateCount = 0;
+
+// Component render counts to detect potential re-rendering issues
+const renderCounts: Record<string, number> = {};
+
+/**
+ * Reset the update counter (typically at the start of a new stream)
+ */
+export function resetStreamingUpdateCount() {
+  updateCount = 0;
+}
+
+/**
+ * Check if we're in a test environment
+ */
+function isTestEnvironment() {
+  return process.env.NODE_ENV === 'test' || process.env.VITEST === 'true';
+}
+
+/**
+ * Log a streaming content update
+ */
+export function logStreamingUpdate(content: string, segmentsCount: number, streamingId?: string) {
+  if (!DEBUG_ENABLED && !FORCE_LOG_IN_TESTS) return;
+
+  const id = streamingId ? ` [${streamingId}]` : '';
+  updateCount++;
+
+  const message = `🔍 STREAM${id}: Update #${updateCount} - Content length=${content.length}, hasSegments=${segmentsCount > 0}`;
+
+  // Format the output based on environment
+  if (typeof window !== 'undefined') {
+    // Browser environment
+    console.debug(message);
+  } else if (isTestEnvironment()) {
+    // Test environment - write directly to stdout for cleaner output
+    process.stdout.write(`\n${message}\n`);
+  }
+}
+
+/**
+ * Log segment details
+ */
+export function logSegmentDetails(segments: Array<{ type: string; content?: string }>) {
+  if ((!DEBUG_ENABLED && !FORCE_LOG_IN_TESTS) || !segments?.length) return;
+
+  segments.forEach((segment, i) => {
+    const previewContent = segment.content
+      ? `${segment.content.substring(0, 20)}${segment.content.length > 20 ? '...' : ''}`
+      : '[empty]';
+
+    const message = `🔍 SEGMENT ${i}: type=${segment.type}, content=${previewContent}`;
+
+    if (typeof window !== 'undefined') {
+      console.debug(message);
+    } else if (isTestEnvironment()) {
+      process.stdout.write(`\n${message}\n`);
+    }
+  });
+}
+
+/**
+ * Log UI state decisions
+ */
+export function logUIState(
+  componentName: string,
+  contentVisible: boolean,
+  segmentsCount: number,
+  additionalInfo?: Record<string, any>
+) {
+  if (!DEBUG_ENABLED && !FORCE_LOG_IN_TESTS) return;
+
+  // Track render counts
+  renderCounts[componentName] = (renderCounts[componentName] || 0) + 1;
+
+  const renderCount = renderCounts[componentName];
+  const additionalInfoStr = additionalInfo
+    ? `, ${Object.entries(additionalInfo)
+        .map(([k, v]) => `${k}=${v}`)
+        .join(', ')}`
+    : '';
+
+  const message = `🔍 UI STATE: ${componentName} render #${renderCount}, contentVisible=${contentVisible}, segmentsRendered=${segmentsCount}${additionalInfoStr}`;
+
+  if (typeof window !== 'undefined') {
+    console.debug(message);
+  } else if (isTestEnvironment()) {
+    process.stdout.write(`\n${message}\n`);
+  }
+}
+
+/**
+ * Log DOM verification for tests
+ */
+export function logDOMVerification(elementText: string, isFound: boolean) {
+  if (!DEBUG_ENABLED && !FORCE_LOG_IN_TESTS) return;
+
+  const message = `🔍 DOM CHECK: "${elementText}" is ${isFound ? 'FOUND' : 'NOT FOUND'} in document`;
+
+  if (typeof window !== 'undefined') {
+    console.debug(message);
+  } else if (isTestEnvironment()) {
+    process.stdout.write(`\n${message}\n`);
+  }
+}
+
+/**
+ * General debug log that works in any environment
+ */
+export function debugLog(message: string) {
+  if (!DEBUG_ENABLED && !FORCE_LOG_IN_TESTS) return;
+
+  if (typeof window !== 'undefined') {
+    console.debug(message);
+  } else if (isTestEnvironment()) {
+    process.stdout.write(`\n${message}\n`);
+  }
+}
+
+export default {
+  resetStreamingUpdateCount,
+  logStreamingUpdate,
+  logSegmentDetails,
+  logUIState,
+  logDOMVerification,
+  debugLog,
+};
diff --git a/app/utils/openRouterApi.ts b/app/utils/openRouterApi.ts
new file mode 100644
index 0000000..e69de29
diff --git a/app/utils/segmentParser.ts b/app/utils/segmentParser.ts
new file mode 100644
index 0000000..0a5ce7f
--- /dev/null
+++ b/app/utils/segmentParser.ts
@@ -0,0 +1,121 @@
+import type { Segment } from '../types/chat';
+
+/**
+ * Parse content into segments of markdown and code
+ * This is a pure function that doesn't rely on any state
+ */
+export function parseContent(text: string): {
+  segments: Segment[];
+  dependenciesString: string | undefined;
+} {
+  const segments: Segment[] = [];
+  let dependenciesString: string | undefined;
+
+  // Extract dependencies from the beginning if they exist
+  // Format 1: {"dependencies": {}}
+  // Format 2: {"react": "^18.2.0", "react-dom": "^18.2.0"}}
+  const depsFormat1 = text.match(/^({"dependencies":\s*{}})/);
+  const depsFormat2 = text.match(/^({(?:"[^"]+"\s*:\s*"[^"]+"(?:,\s*)?)+}})/);
+
+  if (depsFormat1 && depsFormat1[1]) {
+    dependenciesString = depsFormat1[1];
+    // Remove the dependencies part from the text
+    text = text.substring(text.indexOf(depsFormat1[1]) + depsFormat1[1].length).trim();
+  } else if (depsFormat2 && depsFormat2[1]) {
+    dependenciesString = depsFormat2[1];
+    // Remove the dependencies part from the text
+    text = text.substring(text.indexOf(depsFormat2[1]) + depsFormat2[1].length).trim();
+  }
+
+  // First look for complete code blocks delimited by ```js or ```jsx and a closing ```
+  const completeCodeBlockMatch = text.match(/(.*?)\s*```(?:js|jsx)\s*\n([\s\S]*?)```\s*([\s\S]*)/s);
+
+  // Then check for incomplete code blocks with just the opening delimiter
+  const incompleteCodeBlockMatch = text.match(/(.*?)\s*```(?:js|jsx)\s*\n([\s\S]*?)$/s);
+
+  if (completeCodeBlockMatch) {
+    const beforeCode = completeCodeBlockMatch[1]?.trim();
+    const codeContent = completeCodeBlockMatch[2]?.trim();
+    const afterCode = completeCodeBlockMatch[3]?.trim();
+
+    // Add the markdown content before the code block if it exists
+    if (beforeCode) {
+      segments.push({
+        type: 'markdown',
+        content: beforeCode,
+      });
+    }
+
+    // Add the code block
+    if (codeContent) {
+      segments.push({
+        type: 'code',
+        content: codeContent,
+      });
+    }
+
+    // Add the markdown content after the code block if it exists
+    if (afterCode) {
+      segments.push({
+        type: 'markdown',
+        content: afterCode,
+      });
+    }
+  } else if (incompleteCodeBlockMatch) {
+    // Handle incomplete code blocks (missing closing delimiter)
+    const beforeCode = incompleteCodeBlockMatch[1]?.trim();
+    const codeContent = incompleteCodeBlockMatch[2]?.trim();
+
+    // Add the markdown content before the code block if it exists
+    if (beforeCode) {
+      segments.push({
+        type: 'markdown',
+        content: beforeCode,
+      });
+    }
+
+    // Add the incomplete code block
+    if (codeContent) {
+      segments.push({
+        type: 'code',
+        content: codeContent,
+      });
+    }
+  } else {
+    // If no code blocks are found, treat the whole content as markdown
+    segments.push({
+      type: 'markdown',
+      content: text,
+    });
+  }
+
+  return { segments, dependenciesString };
+}
+
+/**
+ * Extract dependencies as a Record from the dependencies string
+ */
+export function parseDependencies(dependenciesString?: string): Record<string, string> {
+  if (!dependenciesString) return {};
+
+  const dependencies: Record<string, string> = {};
+  const matches = dependenciesString.match(/"([^"]+)"\s*:\s*"([^"]+)"/g);
+
+  if (matches) {
+    matches.forEach((match) => {
+      const keyMatch = match.match(/"([^"]+)"\s*:/);
+      const valueMatch = match.match(/:\s*"([^"]+)"/);
+
+      if (keyMatch?.[1] && valueMatch?.[1]) {
+        const key = keyMatch[1].trim();
+        const value = valueMatch[1].trim();
+
+        if (key && value) {
+          dependencies[key] = value;
+        }
+      }
+    });
+  }
+
+  return dependencies;
+}
diff --git a/app/utils/sharing.ts b/app/utils/sharing.ts
new file mode 100644
index 0000000..d7a1e09
--- /dev/null
+++ b/app/utils/sharing.ts
@@ -0,0 +1,68 @@
+/**
+ * Utilities for sharing and clipboard operations
+ */
+
+/**
+ * Copy text to clipboard using the Clipboard API with fallback for older browsers
+ */
+export function copyToClipboard(text: string): void {
+  if (navigator.clipboard) {
+    navigator.clipboard
+      .writeText(text)
+      .then(() => {
+        console.log('Text copied to clipboard');
+      })
+      .catch((err) => {
+        console.error('Failed to copy text: ', err);
+      });
+  } else {
+    // Fallback for older browsers
+    try {
+      const textArea = document.createElement('textarea');
+      textArea.value = text;
+      textArea.style.position = 'fixed';
+      document.body.appendChild(textArea);
+      textArea.focus();
+      textArea.select();
+      document.execCommand('copy');
+      document.body.removeChild(textArea);
+    } catch (err) {
+      console.error('Fallback: Could not copy text: ', err);
+    }
+  }
+}
+
+/**
+ * Encode application state to URL-safe string
+ */
+export function encodeStateToUrl(code: string, dependencies: Record<string, string>): string {
+  try {
+    const stateObj = { code, dependencies };
+    const jsonStr = JSON.stringify(stateObj);
+    const encoded = btoa(encodeURIComponent(jsonStr));
+    return encoded;
+  } catch (error) {
+    console.error('Error encoding state to URL:', error);
+    return '';
+  }
+}
+
+/**
+ * Decode URL-safe string to application state
+ */
+export function decodeStateFromUrl(encoded: string): {
+  code: string;
+  dependencies: Record<string, string>;
+} {
+  try {
+    const jsonStr = decodeURIComponent(atob(encoded));
+    const stateObj = JSON.parse(jsonStr);
+    return {
+      code: stateObj.code || '',
+      dependencies: stateObj.dependencies || {},
+    };
+  } catch (error) {
+    console.error('Error decoding state from URL:', error);
+    return { code: '', dependencies: {} };
+  }
+}
diff --git a/app/utils/streamHandler.ts b/app/utils/streamHandler.ts
new file mode 100644
index 0000000..4d07cc8
--- /dev/null
+++ b/app/utils/streamHandler.ts
@@ -0,0 +1,111 @@
+// Debug logging function
+function logDebug(message: string) {
+  console.debug(`🔍 STREAM_HANDLER: ${message}`);
+}
+
+/**
+ * Utility functions for working with the OpenRouter API
+ */
+
+/**
+ * Call OpenRouter API with streaming enabled
+ *
+ * @param model - The model to use (e.g. 'anthropic/claude-3.7-sonnet')
+ * @param systemPrompt - The system prompt
+ * @param messageHistory - Array of previous messages
+ * @param userMessage - The current user message
+ * @returns A Response object with the stream
+ */
+export async function callOpenRouterAPI(
+  model: string,
+  systemPrompt: string,
+  messageHistory: Array<{ role: 'user' | 'assistant'; content: string }>,
+  userMessage: string
+): Promise<Response> {
+  const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
+    method: 'POST',
+    headers: {
+      Authorization: `Bearer ${import.meta.env.VITE_OPENROUTER_API_KEY}`,
+      'Content-Type': 'application/json',
+      'HTTP-Referer': window.location.origin,
+      'X-Title': 'Fireproof App Builder',
+    },
+    body: JSON.stringify({
+      model: model,
+      stream: true,
+      messages: [
+        {
+          role: 'system',
+          content: systemPrompt,
+        },
+        ...messageHistory,
+        {
+          role: 'user',
+          content: userMessage,
+        },
+      ],
+    }),
+  });
+
+  if (!response.ok) {
+    throw new Error(`HTTP error! Status: ${response.status}`);
+  }
+
+  return response;
+}
+
+/**
+ * Process a streaming response from OpenRouter API
+ *
+ * @param response - The fetch response object with streaming enabled
+ * @param onChunk - Callback function that receives each content chunk as it arrives
+ * @returns A promise that resolves when streaming is complete
+ */
+export async function processStream(
+  response: Response,
+  onChunk: (content: string) => void
+): Promise<void> {
+  if (!response.ok) {
+    throw new Error(`HTTP error! Status: ${response.status}`);
+  }
+
+  const reader = response.body?.getReader();
+  if (!reader) {
+    throw new Error('Response body is not readable');
+  }
+
+  const decoder = new TextDecoder();
+
+  // Process the stream
+  while (true) {
+    const { done, value } = await reader.read();
+    if (done) break;
+
+    // Decode the chunk
+    const chunk = decoder.decode(value, { stream: true });
+
+    // Process SSE format
+    const lines = chunk.split('\n');
+    for (const line of lines) {
+      // Skip OpenRouter processing messages
+      if (line.startsWith(': OPENROUTER PROCESSING')) {
+        continue;
+      }
+
+      if (line.startsWith('data: ') && line !== 'data: [DONE]') {
+        try {
+          const data = JSON.parse(line.substring(6));
+          if (data.choices && data.choices[0]?.delta?.content) {
+            const content = data.choices[0].delta.content;
+            // Call the onChunk callback with the new content
+            onChunk(content);
+          }
+        } catch (e) {
+          console.error('Error parsing SSE JSON:', e);
+        }
+      }
+    }
+  }
+
+  // Function will naturally resolve when streaming is complete
+}
diff --git a/app/utils/titleGenerator.ts b/app/utils/titleGenerator.ts
new file mode 100644
index 0000000..7729b18
--- /dev/null
+++ b/app/utils/titleGenerator.ts
@@ -0,0 +1,59 @@
+import type { Segment } from '../types/chat';
+
+/**
+ * Generate a title based on the first two segments (markdown and code)
+ * Returns a promise that resolves when the title generation is complete
+ *
+ * @param segments - Array of content segments to analyze
+ * @param model - The AI model to use for title generation
+ * @returns A promise that resolves to the generated title or null if generation failed
+ */
+export async function generateTitle(segments: Segment[], model: string): Promise<string> {
+  // Get first markdown segment and first code segment (if they exist)
+  const firstMarkdown = segments.find((seg) => seg.type === 'markdown');
+  const firstCode = segments.find((seg) => seg.type === 'code');
+
+  // Create content from the first two segments
+  let titleContent = '';
+
+  if (firstMarkdown) {
+    titleContent += firstMarkdown.content + '\n\n';
+  }
+
+  if (firstCode) {
+    titleContent += '```\n' + firstCode.content.split('\n').slice(0, 15).join('\n') + '\n```';
+  }
+
+  const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
+    method: 'POST',
+    headers: {
+      Authorization: `Bearer ${import.meta.env.VITE_OPENROUTER_API_KEY}`,
+      'Content-Type': 'application/json',
+      'HTTP-Referer': window.location.origin,
+      'X-Title': 'Fireproof App Builder',
+    },
+    body: JSON.stringify({
+      model,
+      stream: false,
+      messages: [
+        {
+          role: 'system',
+          content:
+            'You are a helpful assistant that generates short, descriptive titles. Create a concise title (3-5 words) that captures the essence of the content. Return only the title, no other text or markup. Don\'t say "Fireproof" or "app".',
+        },
+        {
+          role: 'user',
+          content: `Generate a short, descriptive title (3-5 words) for this app, use the React JSX <h1> tag's value if you can find it:\n\n${titleContent}`,
+        },
+      ],
+    }),
+  });
+
+  if (response.ok) {
+    const data = await response.json();
+    const newTitle = data.choices[0]?.message?.content?.trim();
+    return newTitle || 'New Chat';
+  }
+
+  return 'New Chat';
+}
